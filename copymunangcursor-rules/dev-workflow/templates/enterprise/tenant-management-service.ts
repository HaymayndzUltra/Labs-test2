/**
 * Enterprise SaaS Multi-Tenant Management Service
 * Generated by Enhanced Client Project Scaffold
 * 
 * This service provides comprehensive tenant management capabilities
 * for enterprise SaaS applications with multi-tenant architecture.
 */

import { Injectable, Logger, OnModuleInit } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, DataSource, QueryRunner } from 'typeorm';
import { ConfigService } from '@nestjs/config';
import { EventEmitter2 } from '@nestjs/event-emitter';
import { Cron, CronExpression } from '@nestjs/schedule';
import { v4 as uuidv4 } from 'uuid';
import * as bcrypt from 'bcrypt';
import * as jwt from 'jsonwebtoken';
import { 
  Tenant, 
  TenantUser, 
  TenantConfiguration, 
  TenantSubscription,
  TenantUsage,
  TenantAuditLog 
} from './entities';
import {
  CreateTenantDto,
  UpdateTenantDto,
  TenantResponseDto,
  TenantListResponseDto,
  TenantStatsDto,
  TenantUsageDto,
  TenantConfigurationDto,
  TenantSubscriptionDto,
  TenantMigrationDto,
  TenantBackupDto,
  TenantRestoreDto
} from './dto';
import {
  TenantNotFoundException,
  TenantAlreadyExistsException,
  TenantLimitExceededException,
  TenantInactiveException,
  TenantMigrationException,
  TenantBackupException,
  TenantRestoreException
} from './exceptions';
import {
  TenantCreatedEvent,
  TenantUpdatedEvent,
  TenantDeletedEvent,
  TenantSuspendedEvent,
  TenantActivatedEvent,
  TenantUsageExceededEvent,
  TenantMigrationStartedEvent,
  TenantMigrationCompletedEvent,
  TenantBackupCreatedEvent,
  TenantRestoreStartedEvent
} from './events';

// Tenant Status Enum
export enum TenantStatus {
  ACTIVE = 'active',
  INACTIVE = 'inactive',
  SUSPENDED = 'suspended',
  PENDING = 'pending',
  MIGRATING = 'migrating',
  BACKING_UP = 'backing_up',
  RESTORING = 'restoring',
  DELETED = 'deleted'
}

// Tenant Plan Enum
export enum TenantPlan {
  STARTER = 'starter',
  PROFESSIONAL = 'professional',
  ENTERPRISE = 'enterprise',
  CUSTOM = 'custom'
}

// Tenant Isolation Strategy Enum
export enum IsolationStrategy {
  SHARED_DATABASE = 'shared_database',
  DATABASE_PER_TENANT = 'database_per_tenant',
  SCHEMA_PER_TENANT = 'schema_per_tenant'
}

@Injectable()
export class TenantManagementService implements OnModuleInit {
  private readonly logger = new Logger(TenantManagementService.name);
  private readonly isolationStrategy: IsolationStrategy;
  private readonly maxTenantsPerDatabase: number;
  private readonly tenantDatabasePrefix: string;

  constructor(
    @InjectRepository(Tenant)
    private readonly tenantRepository: Repository<Tenant>,
    @InjectRepository(TenantUser)
    private readonly tenantUserRepository: Repository<TenantUser>,
    @InjectRepository(TenantConfiguration)
    private readonly tenantConfigRepository: Repository<TenantConfiguration>,
    @InjectRepository(TenantSubscription)
    private readonly tenantSubscriptionRepository: Repository<TenantSubscription>,
    @InjectRepository(TenantUsage)
    private readonly tenantUsageRepository: Repository<TenantUsage>,
    @InjectRepository(TenantAuditLog)
    private readonly tenantAuditRepository: Repository<TenantAuditLog>,
    private readonly dataSource: DataSource,
    private readonly configService: ConfigService,
    private readonly eventEmitter: EventEmitter2
  ) {
    this.isolationStrategy = this.configService.get<IsolationStrategy>('TENANT_ISOLATION_STRATEGY', IsolationStrategy.DATABASE_PER_TENANT);
    this.maxTenantsPerDatabase = this.configService.get<number>('MAX_TENANTS_PER_DATABASE', 100);
    this.tenantDatabasePrefix = this.configService.get<string>('TENANT_DATABASE_PREFIX', 'tenant_');
  }

  async onModuleInit() {
    await this.initializeTenantManagement();
  }

  /**
   * Initialize tenant management system
   */
  private async initializeTenantManagement(): Promise<void> {
    try {
      this.logger.log('Initializing tenant management system...');
      
      // Create tenant management tables if they don't exist
      await this.createTenantManagementTables();
      
      // Initialize default tenant configurations
      await this.initializeDefaultConfigurations();
      
      // Start tenant health monitoring
      await this.startTenantHealthMonitoring();
      
      this.logger.log('Tenant management system initialized successfully');
    } catch (error) {
      this.logger.error('Failed to initialize tenant management system', error);
      throw error;
    }
  }

  /**
   * Create tenant management tables
   */
  private async createTenantManagementTables(): Promise<void> {
    const queryRunner = this.dataSource.createQueryRunner();
    await queryRunner.connect();
    await queryRunner.startTransaction();

    try {
      // Create tenant management schema
      await queryRunner.query(`
        CREATE SCHEMA IF NOT EXISTS tenant_management;
      `);

      // Create tenant table
      await queryRunner.query(`
        CREATE TABLE IF NOT EXISTS tenant_management.tenants (
          id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
          name VARCHAR(255) NOT NULL,
          subdomain VARCHAR(255) UNIQUE NOT NULL,
          domain VARCHAR(255),
          status VARCHAR(50) NOT NULL DEFAULT 'pending',
          plan VARCHAR(50) NOT NULL DEFAULT 'starter',
          database_name VARCHAR(255),
          schema_name VARCHAR(255),
          created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
          updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
          created_by UUID,
          updated_by UUID,
          metadata JSONB,
          settings JSONB,
          is_deleted BOOLEAN DEFAULT FALSE,
          deleted_at TIMESTAMP WITH TIME ZONE
        );
      `);

      // Create tenant users table
      await queryRunner.query(`
        CREATE TABLE IF NOT EXISTS tenant_management.tenant_users (
          id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
          tenant_id UUID NOT NULL REFERENCES tenant_management.tenants(id) ON DELETE CASCADE,
          user_id UUID NOT NULL,
          role VARCHAR(50) NOT NULL DEFAULT 'user',
          permissions JSONB,
          is_active BOOLEAN DEFAULT TRUE,
          created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
          updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
        );
      `);

      // Create tenant configurations table
      await queryRunner.query(`
        CREATE TABLE IF NOT EXISTS tenant_management.tenant_configurations (
          id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
          tenant_id UUID NOT NULL REFERENCES tenant_management.tenants(id) ON DELETE CASCADE,
          config_key VARCHAR(255) NOT NULL,
          config_value JSONB NOT NULL,
          config_type VARCHAR(50) NOT NULL DEFAULT 'string',
          is_encrypted BOOLEAN DEFAULT FALSE,
          created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
          updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
          UNIQUE(tenant_id, config_key)
        );
      `);

      // Create tenant subscriptions table
      await queryRunner.query(`
        CREATE TABLE IF NOT EXISTS tenant_management.tenant_subscriptions (
          id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
          tenant_id UUID NOT NULL REFERENCES tenant_management.tenants(id) ON DELETE CASCADE,
          plan VARCHAR(50) NOT NULL,
          status VARCHAR(50) NOT NULL DEFAULT 'active',
          billing_cycle VARCHAR(50) NOT NULL DEFAULT 'monthly',
          price DECIMAL(10,2) NOT NULL,
          currency VARCHAR(3) NOT NULL DEFAULT 'USD',
          start_date TIMESTAMP WITH TIME ZONE NOT NULL,
          end_date TIMESTAMP WITH TIME ZONE,
          auto_renew BOOLEAN DEFAULT TRUE,
          created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
          updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
        );
      `);

      // Create tenant usage table
      await queryRunner.query(`
        CREATE TABLE IF NOT EXISTS tenant_management.tenant_usage (
          id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
          tenant_id UUID NOT NULL REFERENCES tenant_management.tenants(id) ON DELETE CASCADE,
          metric_name VARCHAR(255) NOT NULL,
          metric_value BIGINT NOT NULL DEFAULT 0,
          metric_unit VARCHAR(50) NOT NULL,
          recorded_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
          period_start TIMESTAMP WITH TIME ZONE NOT NULL,
          period_end TIMESTAMP WITH TIME ZONE NOT NULL
        );
      `);

      // Create tenant audit logs table
      await queryRunner.query(`
        CREATE TABLE IF NOT EXISTS tenant_management.tenant_audit_logs (
          id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
          tenant_id UUID NOT NULL REFERENCES tenant_management.tenants(id) ON DELETE CASCADE,
          user_id UUID,
          action VARCHAR(255) NOT NULL,
          resource_type VARCHAR(255) NOT NULL,
          resource_id VARCHAR(255),
          old_values JSONB,
          new_values JSONB,
          ip_address INET,
          user_agent TEXT,
          created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
        );
      `);

      // Create indexes
      await queryRunner.query(`
        CREATE INDEX IF NOT EXISTS idx_tenants_subdomain ON tenant_management.tenants(subdomain);
        CREATE INDEX IF NOT EXISTS idx_tenants_status ON tenant_management.tenants(status);
        CREATE INDEX IF NOT EXISTS idx_tenants_plan ON tenant_management.tenants(plan);
        CREATE INDEX IF NOT EXISTS idx_tenant_users_tenant_id ON tenant_management.tenant_users(tenant_id);
        CREATE INDEX IF NOT EXISTS idx_tenant_users_user_id ON tenant_management.tenant_users(user_id);
        CREATE INDEX IF NOT EXISTS idx_tenant_configurations_tenant_id ON tenant_management.tenant_configurations(tenant_id);
        CREATE INDEX IF NOT EXISTS idx_tenant_subscriptions_tenant_id ON tenant_management.tenant_subscriptions(tenant_id);
        CREATE INDEX IF NOT EXISTS idx_tenant_usage_tenant_id ON tenant_management.tenant_usage(tenant_id);
        CREATE INDEX IF NOT EXISTS idx_tenant_audit_logs_tenant_id ON tenant_management.tenant_audit_logs(tenant_id);
        CREATE INDEX IF NOT EXISTS idx_tenant_audit_logs_created_at ON tenant_management.tenant_audit_logs(created_at);
      `);

      await queryRunner.commitTransaction();
    } catch (error) {
      await queryRunner.rollbackTransaction();
      throw error;
    } finally {
      await queryRunner.release();
    }
  }

  /**
   * Initialize default tenant configurations
   */
  private async initializeDefaultConfigurations(): Promise<void> {
    const defaultConfigs = [
      { key: 'max_users', value: 100, type: 'number' },
      { key: 'max_storage', value: '10GB', type: 'string' },
      { key: 'max_api_calls', value: 10000, type: 'number' },
      { key: 'features', value: ['basic_analytics', 'standard_support', 'api_access'], type: 'array' },
      { key: 'retention_period', value: 30, type: 'number' },
      { key: 'backup_frequency', value: 'daily', type: 'string' },
      { key: 'monitoring_enabled', value: true, type: 'boolean' },
      { key: 'audit_logging', value: true, type: 'boolean' }
    ];

    // Store default configurations in a system tenant
    const systemTenantId = '00000000-0000-0000-0000-000000000000';
    
    for (const config of defaultConfigs) {
      await this.tenantConfigRepository.save({
        tenantId: systemTenantId,
        configKey: config.key,
        configValue: config.value,
        configType: config.type,
        isEncrypted: false
      });
    }
  }

  /**
   * Start tenant health monitoring
   */
  private async startTenantHealthMonitoring(): Promise<void> {
    this.logger.log('Starting tenant health monitoring...');
    // Health monitoring will be implemented in the cron job
  }

  /**
   * Create a new tenant
   */
  async createTenant(createTenantDto: CreateTenantDto, createdBy: string): Promise<TenantResponseDto> {
    const queryRunner = this.dataSource.createQueryRunner();
    await queryRunner.connect();
    await queryRunner.startTransaction();

    try {
      // Check if tenant already exists
      const existingTenant = await this.tenantRepository.findOne({
        where: { subdomain: createTenantDto.subdomain }
      });

      if (existingTenant) {
        throw new TenantAlreadyExistsException(createTenantDto.subdomain);
      }

      // Generate tenant ID
      const tenantId = uuidv4();

      // Create tenant database/schema based on isolation strategy
      const databaseName = await this.createTenantDatabase(tenantId, createTenantDto.subdomain);
      const schemaName = await this.createTenantSchema(tenantId, createTenantDto.subdomain);

      // Create tenant record
      const tenant = await this.tenantRepository.save({
        id: tenantId,
        name: createTenantDto.name,
        subdomain: createTenantDto.subdomain,
        domain: createTenantDto.domain,
        status: TenantStatus.PENDING,
        plan: createTenantDto.plan || TenantPlan.STARTER,
        databaseName: databaseName,
        schemaName: schemaName,
        createdBy: createdBy,
        metadata: createTenantDto.metadata || {},
        settings: createTenantDto.settings || {}
      });

      // Initialize tenant configuration
      await this.initializeTenantConfiguration(tenantId, createTenantDto.plan || TenantPlan.STARTER);

      // Create tenant subscription
      await this.createTenantSubscription(tenantId, createTenantDto.plan || TenantPlan.STARTER);

      // Initialize tenant usage tracking
      await this.initializeTenantUsage(tenantId);

      // Log tenant creation
      await this.logTenantAction(tenantId, createdBy, 'TENANT_CREATED', 'tenant', tenantId, null, {
        name: createTenantDto.name,
        subdomain: createTenantDto.subdomain,
        plan: createTenantDto.plan
      });

      // Emit tenant created event
      this.eventEmitter.emit('tenant.created', new TenantCreatedEvent(tenantId, createTenantDto.name, createTenantDto.subdomain));

      await queryRunner.commitTransaction();

      return this.mapTenantToResponseDto(tenant);
    } catch (error) {
      await queryRunner.rollbackTransaction();
      this.logger.error('Failed to create tenant', error);
      throw error;
    } finally {
      await queryRunner.release();
    }
  }

  /**
   * Create tenant database based on isolation strategy
   */
  private async createTenantDatabase(tenantId: string, subdomain: string): Promise<string> {
    const databaseName = `${this.tenantDatabasePrefix}${tenantId.replace(/-/g, '_')}`;
    
    if (this.isolationStrategy === IsolationStrategy.DATABASE_PER_TENANT) {
      const queryRunner = this.dataSource.createQueryRunner();
      await queryRunner.connect();
      
      try {
        // Create database
        await queryRunner.query(`CREATE DATABASE "${databaseName}"`);
        
        // Create tenant-specific tables
        await this.createTenantSpecificTables(databaseName);
        
        this.logger.log(`Created tenant database: ${databaseName}`);
      } finally {
        await queryRunner.release();
      }
    }
    
    return databaseName;
  }

  /**
   * Create tenant schema based on isolation strategy
   */
  private async createTenantSchema(tenantId: string, subdomain: string): Promise<string> {
    const schemaName = `tenant_${tenantId.replace(/-/g, '_')}`;
    
    if (this.isolationStrategy === IsolationStrategy.SCHEMA_PER_TENANT) {
      const queryRunner = this.dataSource.createQueryRunner();
      await queryRunner.connect();
      
      try {
        // Create schema
        await queryRunner.query(`CREATE SCHEMA IF NOT EXISTS "${schemaName}"`);
        
        // Create tenant-specific tables in schema
        await this.createTenantSpecificTablesInSchema(schemaName);
        
        this.logger.log(`Created tenant schema: ${schemaName}`);
      } finally {
        await queryRunner.release();
      }
    }
    
    return schemaName;
  }

  /**
   * Create tenant-specific tables
   */
  private async createTenantSpecificTables(databaseName: string): Promise<void> {
    // This would create all the necessary tables for the tenant
    // Implementation depends on your specific application requirements
    this.logger.log(`Creating tenant-specific tables for database: ${databaseName}`);
  }

  /**
   * Create tenant-specific tables in schema
   */
  private async createTenantSpecificTablesInSchema(schemaName: string): Promise<void> {
    // This would create all the necessary tables for the tenant in the schema
    // Implementation depends on your specific application requirements
    this.logger.log(`Creating tenant-specific tables in schema: ${schemaName}`);
  }

  /**
   * Initialize tenant configuration
   */
  private async initializeTenantConfiguration(tenantId: string, plan: TenantPlan): Promise<void> {
    const planConfigs = this.getPlanConfigurations(plan);
    
    for (const [key, value] of Object.entries(planConfigs)) {
      await this.tenantConfigRepository.save({
        tenantId: tenantId,
        configKey: key,
        configValue: value,
        configType: typeof value === 'number' ? 'number' : typeof value === 'boolean' ? 'boolean' : 'string',
        isEncrypted: false
      });
    }
  }

  /**
   * Get plan configurations
   */
  private getPlanConfigurations(plan: TenantPlan): Record<string, any> {
    const planConfigs = {
      [TenantPlan.STARTER]: {
        max_users: 10,
        max_storage: '1GB',
        max_api_calls: 1000,
        features: ['basic_analytics', 'email_support', 'api_access'],
        price: 29.99
      },
      [TenantPlan.PROFESSIONAL]: {
        max_users: 100,
        max_storage: '10GB',
        max_api_calls: 10000,
        features: ['advanced_analytics', 'priority_support', 'api_access', 'custom_integrations'],
        price: 99.99
      },
      [TenantPlan.ENTERPRISE]: {
        max_users: 1000,
        max_storage: '100GB',
        max_api_calls: 100000,
        features: ['premium_analytics', 'dedicated_support', 'api_access', 'custom_integrations', 'sso_integration', 'audit_logs'],
        price: 299.99
      },
      [TenantPlan.CUSTOM]: {
        max_users: -1, // unlimited
        max_storage: 'unlimited',
        max_api_calls: -1, // unlimited
        features: 'all',
        price: 'custom'
      }
    };

    return planConfigs[plan] || planConfigs[TenantPlan.STARTER];
  }

  /**
   * Create tenant subscription
   */
  private async createTenantSubscription(tenantId: string, plan: TenantPlan): Promise<void> {
    const planConfig = this.getPlanConfigurations(plan);
    
    await this.tenantSubscriptionRepository.save({
      tenantId: tenantId,
      plan: plan,
      status: 'active',
      billingCycle: 'monthly',
      price: planConfig.price,
      currency: 'USD',
      startDate: new Date(),
      autoRenew: true
    });
  }

  /**
   * Initialize tenant usage tracking
   */
  private async initializeTenantUsage(tenantId: string): Promise<void> {
    const usageMetrics = [
      { metric_name: 'users', metric_value: 0, metric_unit: 'count' },
      { metric_name: 'storage', metric_value: 0, metric_unit: 'bytes' },
      { metric_name: 'api_calls', metric_value: 0, metric_unit: 'count' },
      { metric_name: 'requests', metric_value: 0, metric_unit: 'count' },
      { metric_name: 'errors', metric_value: 0, metric_unit: 'count' }
    ];

    const now = new Date();
    const periodStart = new Date(now.getFullYear(), now.getMonth(), 1);
    const periodEnd = new Date(now.getFullYear(), now.getMonth() + 1, 0);

    for (const metric of usageMetrics) {
      await this.tenantUsageRepository.save({
        tenantId: tenantId,
        metricName: metric.metric_name,
        metricValue: metric.metric_value,
        metricUnit: metric.metric_unit,
        periodStart: periodStart,
        periodEnd: periodEnd
      });
    }
  }

  /**
   * Get tenant by ID
   */
  async getTenantById(tenantId: string): Promise<TenantResponseDto> {
    const tenant = await this.tenantRepository.findOne({
      where: { id: tenantId, isDeleted: false }
    });

    if (!tenant) {
      throw new TenantNotFoundException(tenantId);
    }

    return this.mapTenantToResponseDto(tenant);
  }

  /**
   * Get tenant by subdomain
   */
  async getTenantBySubdomain(subdomain: string): Promise<TenantResponseDto> {
    const tenant = await this.tenantRepository.findOne({
      where: { subdomain: subdomain, isDeleted: false }
    });

    if (!tenant) {
      throw new TenantNotFoundException(subdomain);
    }

    return this.mapTenantToResponseDto(tenant);
  }

  /**
   * List tenants with pagination and filtering
   */
  async listTenants(
    page: number = 1,
    limit: number = 10,
    status?: TenantStatus,
    plan?: TenantPlan,
    search?: string
  ): Promise<TenantListResponseDto> {
    const queryBuilder = this.tenantRepository
      .createQueryBuilder('tenant')
      .where('tenant.isDeleted = :isDeleted', { isDeleted: false });

    if (status) {
      queryBuilder.andWhere('tenant.status = :status', { status });
    }

    if (plan) {
      queryBuilder.andWhere('tenant.plan = :plan', { plan });
    }

    if (search) {
      queryBuilder.andWhere(
        '(tenant.name ILIKE :search OR tenant.subdomain ILIKE :search OR tenant.domain ILIKE :search)',
        { search: `%${search}%` }
      );
    }

    const [tenants, total] = await queryBuilder
      .orderBy('tenant.createdAt', 'DESC')
      .skip((page - 1) * limit)
      .take(limit)
      .getManyAndCount();

    return {
      tenants: tenants.map(tenant => this.mapTenantToResponseDto(tenant)),
      total,
      page,
      limit,
      totalPages: Math.ceil(total / limit)
    };
  }

  /**
   * Update tenant
   */
  async updateTenant(tenantId: string, updateTenantDto: UpdateTenantDto, updatedBy: string): Promise<TenantResponseDto> {
    const tenant = await this.tenantRepository.findOne({
      where: { id: tenantId, isDeleted: false }
    });

    if (!tenant) {
      throw new TenantNotFoundException(tenantId);
    }

    const oldValues = { ...tenant };

    // Update tenant
    Object.assign(tenant, updateTenantDto);
    tenant.updatedAt = new Date();
    tenant.updatedBy = updatedBy;

    const updatedTenant = await this.tenantRepository.save(tenant);

    // Log tenant update
    await this.logTenantAction(tenantId, updatedBy, 'TENANT_UPDATED', 'tenant', tenantId, oldValues, updateTenantDto);

    // Emit tenant updated event
    this.eventEmitter.emit('tenant.updated', new TenantUpdatedEvent(tenantId, tenant.name, tenant.subdomain));

    return this.mapTenantToResponseDto(updatedTenant);
  }

  /**
   * Suspend tenant
   */
  async suspendTenant(tenantId: string, reason: string, suspendedBy: string): Promise<TenantResponseDto> {
    const tenant = await this.tenantRepository.findOne({
      where: { id: tenantId, isDeleted: false }
    });

    if (!tenant) {
      throw new TenantNotFoundException(tenantId);
    }

    if (tenant.status === TenantStatus.SUSPENDED) {
      throw new Error('Tenant is already suspended');
    }

    const oldValues = { ...tenant };
    tenant.status = TenantStatus.SUSPENDED;
    tenant.updatedAt = new Date();
    tenant.updatedBy = suspendedBy;

    const updatedTenant = await this.tenantRepository.save(tenant);

    // Log tenant suspension
    await this.logTenantAction(tenantId, suspendedBy, 'TENANT_SUSPENDED', 'tenant', tenantId, oldValues, {
      status: TenantStatus.SUSPENDED,
      reason: reason
    });

    // Emit tenant suspended event
    this.eventEmitter.emit('tenant.suspended', new TenantSuspendedEvent(tenantId, tenant.name, reason));

    return this.mapTenantToResponseDto(updatedTenant);
  }

  /**
   * Activate tenant
   */
  async activateTenant(tenantId: string, activatedBy: string): Promise<TenantResponseDto> {
    const tenant = await this.tenantRepository.findOne({
      where: { id: tenantId, isDeleted: false }
    });

    if (!tenant) {
      throw new TenantNotFoundException(tenantId);
    }

    if (tenant.status === TenantStatus.ACTIVE) {
      throw new Error('Tenant is already active');
    }

    const oldValues = { ...tenant };
    tenant.status = TenantStatus.ACTIVE;
    tenant.updatedAt = new Date();
    tenant.updatedBy = activatedBy;

    const updatedTenant = await this.tenantRepository.save(tenant);

    // Log tenant activation
    await this.logTenantAction(tenantId, activatedBy, 'TENANT_ACTIVATED', 'tenant', tenantId, oldValues, {
      status: TenantStatus.ACTIVE
    });

    // Emit tenant activated event
    this.eventEmitter.emit('tenant.activated', new TenantActivatedEvent(tenantId, tenant.name));

    return this.mapTenantToResponseDto(updatedTenant);
  }

  /**
   * Delete tenant (soft delete)
   */
  async deleteTenant(tenantId: string, deletedBy: string): Promise<void> {
    const tenant = await this.tenantRepository.findOne({
      where: { id: tenantId, isDeleted: false }
    });

    if (!tenant) {
      throw new TenantNotFoundException(tenantId);
    }

    const oldValues = { ...tenant };
    tenant.isDeleted = true;
    tenant.deletedAt = new Date();
    tenant.updatedBy = deletedBy;

    await this.tenantRepository.save(tenant);

    // Log tenant deletion
    await this.logTenantAction(tenantId, deletedBy, 'TENANT_DELETED', 'tenant', tenantId, oldValues, {
      isDeleted: true,
      deletedAt: tenant.deletedAt
    });

    // Emit tenant deleted event
    this.eventEmitter.emit('tenant.deleted', new TenantDeletedEvent(tenantId, tenant.name, tenant.subdomain));
  }

  /**
   * Get tenant statistics
   */
  async getTenantStats(tenantId: string): Promise<TenantStatsDto> {
    const tenant = await this.tenantRepository.findOne({
      where: { id: tenantId, isDeleted: false }
    });

    if (!tenant) {
      throw new TenantNotFoundException(tenantId);
    }

    // Get usage statistics
    const usageStats = await this.tenantUsageRepository
      .createQueryBuilder('usage')
      .where('usage.tenantId = :tenantId', { tenantId })
      .andWhere('usage.recordedAt >= :startDate', { 
        startDate: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) // Last 30 days
      })
      .getMany();

    // Calculate statistics
    const stats: TenantStatsDto = {
      tenantId: tenantId,
      totalUsers: 0,
      totalStorage: 0,
      totalApiCalls: 0,
      totalRequests: 0,
      totalErrors: 0,
      uptime: 0,
      lastActivity: tenant.updatedAt,
      healthScore: 100
    };

    for (const usage of usageStats) {
      switch (usage.metricName) {
        case 'users':
          stats.totalUsers = usage.metricValue;
          break;
        case 'storage':
          stats.totalStorage = usage.metricValue;
          break;
        case 'api_calls':
          stats.totalApiCalls = usage.metricValue;
          break;
        case 'requests':
          stats.totalRequests = usage.metricValue;
          break;
        case 'errors':
          stats.totalErrors = usage.metricValue;
          break;
      }
    }

    // Calculate health score
    const errorRate = stats.totalRequests > 0 ? (stats.totalErrors / stats.totalRequests) * 100 : 0;
    stats.healthScore = Math.max(0, 100 - errorRate);

    return stats;
  }

  /**
   * Migrate tenant to new database/schema
   */
  async migrateTenant(tenantId: string, migrationDto: TenantMigrationDto, migratedBy: string): Promise<void> {
    const tenant = await this.tenantRepository.findOne({
      where: { id: tenantId, isDeleted: false }
    });

    if (!tenant) {
      throw new TenantNotFoundException(tenantId);
    }

    try {
      // Update tenant status to migrating
      tenant.status = TenantStatus.MIGRATING;
      await this.tenantRepository.save(tenant);

      // Emit migration started event
      this.eventEmitter.emit('tenant.migration.started', new TenantMigrationStartedEvent(tenantId, migrationDto.targetDatabase));

      // Perform migration based on strategy
      if (migrationDto.strategy === 'database_per_tenant') {
        await this.migrateTenantToNewDatabase(tenantId, migrationDto.targetDatabase);
      } else if (migrationDto.strategy === 'schema_per_tenant') {
        await this.migrateTenantToNewSchema(tenantId, migrationDto.targetSchema);
      }

      // Update tenant with new database/schema info
      tenant.databaseName = migrationDto.targetDatabase;
      tenant.schemaName = migrationDto.targetSchema;
      tenant.status = TenantStatus.ACTIVE;
      await this.tenantRepository.save(tenant);

      // Emit migration completed event
      this.eventEmitter.emit('tenant.migration.completed', new TenantMigrationCompletedEvent(tenantId, migrationDto.targetDatabase));

      // Log migration
      await this.logTenantAction(tenantId, migratedBy, 'TENANT_MIGRATED', 'tenant', tenantId, null, migrationDto);

    } catch (error) {
      // Update tenant status back to active on failure
      tenant.status = TenantStatus.ACTIVE;
      await this.tenantRepository.save(tenant);

      this.logger.error('Tenant migration failed', error);
      throw new TenantMigrationException(tenantId, error.message);
    }
  }

  /**
   * Create tenant backup
   */
  async createTenantBackup(tenantId: string, backupDto: TenantBackupDto, createdBy: string): Promise<string> {
    const tenant = await this.tenantRepository.findOne({
      where: { id: tenantId, isDeleted: false }
    });

    if (!tenant) {
      throw new TenantNotFoundException(tenantId);
    }

    try {
      // Update tenant status to backing up
      tenant.status = TenantStatus.BACKING_UP;
      await this.tenantRepository.save(tenant);

      // Emit backup started event
      this.eventEmitter.emit('tenant.backup.started', new TenantBackupCreatedEvent(tenantId, backupDto.backupType));

      // Create backup
      const backupId = await this.performTenantBackup(tenantId, backupDto);

      // Update tenant status back to active
      tenant.status = TenantStatus.ACTIVE;
      await this.tenantRepository.save(tenant);

      // Log backup creation
      await this.logTenantAction(tenantId, createdBy, 'TENANT_BACKUP_CREATED', 'backup', backupId, null, backupDto);

      return backupId;

    } catch (error) {
      // Update tenant status back to active on failure
      tenant.status = TenantStatus.ACTIVE;
      await this.tenantRepository.save(tenant);

      this.logger.error('Tenant backup failed', error);
      throw new TenantBackupException(tenantId, error.message);
    }
  }

  /**
   * Restore tenant from backup
   */
  async restoreTenant(tenantId: string, restoreDto: TenantRestoreDto, restoredBy: string): Promise<void> {
    const tenant = await this.tenantRepository.findOne({
      where: { id: tenantId, isDeleted: false }
    });

    if (!tenant) {
      throw new TenantNotFoundException(tenantId);
    }

    try {
      // Update tenant status to restoring
      tenant.status = TenantStatus.RESTORING;
      await this.tenantRepository.save(tenant);

      // Emit restore started event
      this.eventEmitter.emit('tenant.restore.started', new TenantRestoreStartedEvent(tenantId, restoreDto.backupId));

      // Perform restore
      await this.performTenantRestore(tenantId, restoreDto);

      // Update tenant status back to active
      tenant.status = TenantStatus.ACTIVE;
      await this.tenantRepository.save(tenant);

      // Log restore
      await this.logTenantAction(tenantId, restoredBy, 'TENANT_RESTORED', 'restore', restoreDto.backupId, null, restoreDto);

    } catch (error) {
      // Update tenant status back to active on failure
      tenant.status = TenantStatus.ACTIVE;
      await this.tenantRepository.save(tenant);

      this.logger.error('Tenant restore failed', error);
      throw new TenantRestoreException(tenantId, error.message);
    }
  }

  /**
   * Perform tenant backup
   */
  private async performTenantBackup(tenantId: string, backupDto: TenantBackupDto): Promise<string> {
    const backupId = uuidv4();
    
    // Implementation would depend on your backup strategy
    // This is a placeholder for the actual backup logic
    this.logger.log(`Creating backup ${backupId} for tenant ${tenantId}`);
    
    return backupId;
  }

  /**
   * Perform tenant restore
   */
  private async performTenantRestore(tenantId: string, restoreDto: TenantRestoreDto): Promise<void> {
    // Implementation would depend on your restore strategy
    // This is a placeholder for the actual restore logic
    this.logger.log(`Restoring tenant ${tenantId} from backup ${restoreDto.backupId}`);
  }

  /**
   * Migrate tenant to new database
   */
  private async migrateTenantToNewDatabase(tenantId: string, targetDatabase: string): Promise<void> {
    // Implementation would depend on your migration strategy
    // This is a placeholder for the actual migration logic
    this.logger.log(`Migrating tenant ${tenantId} to database ${targetDatabase}`);
  }

  /**
   * Migrate tenant to new schema
   */
  private async migrateTenantToNewSchema(tenantId: string, targetSchema: string): Promise<void> {
    // Implementation would depend on your migration strategy
    // This is a placeholder for the actual migration logic
    this.logger.log(`Migrating tenant ${tenantId} to schema ${targetSchema}`);
  }

  /**
   * Log tenant action
   */
  private async logTenantAction(
    tenantId: string,
    userId: string,
    action: string,
    resourceType: string,
    resourceId: string,
    oldValues: any,
    newValues: any
  ): Promise<void> {
    await this.tenantAuditRepository.save({
      tenantId: tenantId,
      userId: userId,
      action: action,
      resourceType: resourceType,
      resourceId: resourceId,
      oldValues: oldValues,
      newValues: newValues,
      ipAddress: null, // Would be passed from request context
      userAgent: null // Would be passed from request context
    });
  }

  /**
   * Map tenant entity to response DTO
   */
  private mapTenantToResponseDto(tenant: Tenant): TenantResponseDto {
    return {
      id: tenant.id,
      name: tenant.name,
      subdomain: tenant.subdomain,
      domain: tenant.domain,
      status: tenant.status,
      plan: tenant.plan,
      databaseName: tenant.databaseName,
      schemaName: tenant.schemaName,
      createdAt: tenant.createdAt,
      updatedAt: tenant.updatedAt,
      createdBy: tenant.createdBy,
      updatedBy: tenant.updatedBy,
      metadata: tenant.metadata,
      settings: tenant.settings
    };
  }

  /**
   * Health check for tenant management service
   */
  @Cron(CronExpression.EVERY_5_MINUTES)
  async performHealthCheck(): Promise<void> {
    try {
      this.logger.log('Performing tenant health check...');
      
      // Check tenant statuses
      const tenants = await this.tenantRepository.find({
        where: { isDeleted: false }
      });

      for (const tenant of tenants) {
        // Check if tenant is healthy
        const isHealthy = await this.checkTenantHealth(tenant.id);
        
        if (!isHealthy) {
          this.logger.warn(`Tenant ${tenant.id} is unhealthy`);
          // Could trigger alerts or automatic recovery
        }
      }

      this.logger.log('Tenant health check completed');
    } catch (error) {
      this.logger.error('Tenant health check failed', error);
    }
  }

  /**
   * Check if tenant is healthy
   */
  private async checkTenantHealth(tenantId: string): Promise<boolean> {
    try {
      // Implementation would check various health indicators
      // This is a placeholder for the actual health check logic
      return true;
    } catch (error) {
      this.logger.error(`Health check failed for tenant ${tenantId}`, error);
      return false;
    }
  }
}

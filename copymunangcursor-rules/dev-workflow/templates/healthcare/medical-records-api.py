"""
HIPAA Compliant Medical Records API
Generated by Enhanced Client Project Scaffold

This module provides secure, HIPAA-compliant access to medical records
with proper encryption, audit logging, and access controls.
"""

from fastapi import FastAPI, HTTPException, Depends, Request, Response
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.trustedhost import TrustedHostMiddleware
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from pydantic import BaseModel, Field, validator
from typing import List, Optional, Dict, Any
from datetime import datetime, timedelta
import logging
import hashlib
import hmac
import json
import os
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
import base64
import uuid
import psycopg2
from psycopg2.extras import RealDictCursor
import redis
from sqlalchemy import create_engine, Column, String, DateTime, Boolean, Text, JSON
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker, Session
import jwt
from passlib.context import CryptContext
import asyncio
from contextlib import asynccontextmanager

# Configure logging for HIPAA compliance
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('logs/hipaa_audit.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# HIPAA Configuration
HIPAA_CONFIG = {
    'encryption_algorithm': 'AES-256-GCM',
    'key_rotation_days': 90,
    'session_timeout_minutes': 15,
    'audit_retention_years': 7,
    'phi_fields': [
        'patient_id', 'medical_record_number', 'diagnosis', 
        'treatment_plan', 'medication_history', 'allergies',
        'date_of_birth', 'ssn', 'insurance_id'
    ],
    'access_levels': ['restricted', 'standard', 'full'],
    'required_consent': True
}

# Database Configuration
DATABASE_URL = os.getenv('DATABASE_URL', 'postgresql://user:password@localhost/medical_records')
REDIS_URL = os.getenv('REDIS_URL', 'redis://localhost:6379')

# Initialize database
engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

# Initialize Redis for caching
redis_client = redis.from_url(REDIS_URL)

# Initialize password hashing
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# Initialize JWT secret
JWT_SECRET = os.getenv('JWT_SECRET', 'your-secret-key')
JWT_ALGORITHM = "HS256"

# Security
security = HTTPBearer()

# Database Models
class Patient(Base):
    __tablename__ = "patients"
    
    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))
    patient_id = Column(String, unique=True, nullable=False)
    medical_record_number = Column(String, unique=True, nullable=False)
    encrypted_data = Column(Text, nullable=False)  # All PHI encrypted
    phi_access_level = Column(String, default='restricted')
    consent_given = Column(Boolean, default=False)
    consent_date = Column(DateTime)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

class AuditLog(Base):
    __tablename__ = "audit_logs"
    
    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))
    user_id = Column(String, nullable=False)
    action = Column(String, nullable=False)
    resource = Column(String, nullable=False)
    details = Column(JSON)
    ip_address = Column(String)
    phi_accessed = Column(Boolean, default=False)
    access_reason = Column(Text)
    created_at = Column(DateTime, default=datetime.utcnow)

class User(Base):
    __tablename__ = "users"
    
    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))
    email = Column(String, unique=True, nullable=False)
    password_hash = Column(String, nullable=False)
    role = Column(String, default='user')
    phi_access_level = Column(String, default='restricted')
    mfa_enabled = Column(Boolean, default=False)
    last_password_change = Column(DateTime, default=datetime.utcnow)
    created_at = Column(DateTime, default=datetime.utcnow)

# Pydantic Models
class PatientData(BaseModel):
    patient_id: str = Field(..., description="Unique patient identifier")
    medical_record_number: str = Field(..., description="Medical record number")
    name: str = Field(..., description="Patient full name")
    date_of_birth: datetime = Field(..., description="Date of birth")
    diagnosis: Optional[str] = Field(None, description="Primary diagnosis")
    treatment_plan: Optional[str] = Field(None, description="Treatment plan")
    medications: List[str] = Field(default_factory=list, description="Current medications")
    allergies: List[str] = Field(default_factory=list, description="Known allergies")
    conditions: List[str] = Field(default_factory=list, description="Medical conditions")
    
    @validator('patient_id')
    def validate_patient_id(cls, v):
        if not v or len(v) < 3:
            raise ValueError('Patient ID must be at least 3 characters')
        return v

class AccessRequest(BaseModel):
    patient_id: str
    access_reason: str = Field(..., min_length=10, description="Detailed reason for access")
    data_usage: str = Field(..., description="Purpose of data usage")
    retention_period: int = Field(7, ge=1, le=10, description="Data retention period in years")

class ConsentRequest(BaseModel):
    patient_id: str
    consent_given: bool = Field(..., description="Patient consent status")
    access_reason: str = Field(..., min_length=10)
    data_usage: str = Field(..., description="Purpose of data usage")

class AuditLogEntry(BaseModel):
    user_id: str
    action: str
    resource: str
    details: Optional[Dict[str, Any]] = None
    ip_address: Optional[str] = None
    phi_accessed: bool = False
    access_reason: Optional[str] = None

# Encryption/Decryption Functions
class HIPAAEncryption:
    def __init__(self):
        self.key = self._get_or_create_key()
        self.cipher = Fernet(self.key)
    
    def _get_or_create_key(self) -> bytes:
        """Get or create encryption key for PHI data"""
        key_file = 'config/encryption.key'
        if os.path.exists(key_file):
            with open(key_file, 'rb') as f:
                return f.read()
        else:
            key = Fernet.generate_key()
            os.makedirs(os.path.dirname(key_file), exist_ok=True)
            with open(key_file, 'wb') as f:
                f.write(key)
            return key
    
    def encrypt_phi(self, data: Dict[str, Any]) -> str:
        """Encrypt PHI data using AES-256-GCM"""
        json_data = json.dumps(data, default=str)
        encrypted_data = self.cipher.encrypt(json_data.encode())
        return base64.b64encode(encrypted_data).decode()
    
    def decrypt_phi(self, encrypted_data: str) -> Dict[str, Any]:
        """Decrypt PHI data"""
        try:
            decoded_data = base64.b64decode(encrypted_data.encode())
            decrypted_data = self.cipher.decrypt(decoded_data)
            return json.loads(decrypted_data.decode())
        except Exception as e:
            logger.error(f"Decryption failed: {e}")
            raise HTTPException(status_code=400, detail="Failed to decrypt data")
    
    def hash_phi(self, data: str) -> str:
        """Create hash for PHI data integrity verification"""
        return hashlib.sha256(data.encode()).hexdigest()

# Initialize encryption
encryption = HIPAAEncryption()

# Authentication Functions
def verify_token(credentials: HTTPAuthorizationCredentials = Depends(security)):
    """Verify JWT token and return user info"""
    try:
        payload = jwt.decode(credentials.credentials, JWT_SECRET, algorithms=[JWT_ALGORITHM])
        user_id = payload.get("sub")
        if user_id is None:
            raise HTTPException(status_code=401, detail="Invalid token")
        return user_id
    except jwt.PyJWTError:
        raise HTTPException(status_code=401, detail="Invalid token")

def get_db():
    """Get database session"""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

def get_current_user(user_id: str = Depends(verify_token), db: Session = Depends(get_db)):
    """Get current user from database"""
    user = db.query(User).filter(User.id == user_id).first()
    if not user:
        raise HTTPException(status_code=401, detail="User not found")
    return user

# Audit Logging Functions
def log_phi_access(
    user_id: str,
    action: str,
    resource: str,
    phi_accessed: bool,
    access_reason: str,
    ip_address: str,
    db: Session
):
    """Log PHI access for HIPAA compliance"""
    audit_entry = AuditLog(
        user_id=user_id,
        action=action,
        resource=resource,
        phi_accessed=phi_accessed,
        access_reason=access_reason,
        ip_address=ip_address
    )
    db.add(audit_entry)
    db.commit()
    logger.info(f"PHI Access Logged: {action} on {resource} by {user_id}")

def check_phi_access_permission(user: User, patient_id: str) -> bool:
    """Check if user has permission to access PHI"""
    if user.phi_access_level == 'restricted':
        return False
    if user.phi_access_level == 'standard':
        # Additional checks for standard access
        return True
    if user.phi_access_level == 'full':
        return True
    return False

# API Endpoints
app = FastAPI(
    title="HIPAA Compliant Medical Records API",
    description="Secure medical records API with HIPAA compliance",
    version="1.0.0",
    docs_url="/docs" if os.getenv("ENVIRONMENT") == "development" else None,
    redoc_url="/redoc" if os.getenv("ENVIRONMENT") == "development" else None
)

# Security Middleware
app.add_middleware(
    TrustedHostMiddleware,
    allowed_hosts=["*"] if os.getenv("ENVIRONMENT") == "development" else ["medical-records.example.com"]
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=os.getenv("ALLOWED_ORIGINS", "*").split(","),
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# HIPAA Compliance Middleware
@app.middleware("http")
async def hipaa_logging_middleware(request: Request, call_next):
    """Log all requests for HIPAA compliance"""
    start_time = datetime.utcnow()
    
    # Log request
    logger.info(f"[HIPAA] {request.method} {request.url} - {start_time.isoformat()}")
    
    response = await call_next(request)
    
    # Log response
    process_time = (datetime.utcnow() - start_time).total_seconds()
    logger.info(f"[HIPAA] Response {response.status_code} - {process_time}s")
    
    return response

@app.get("/")
async def root():
    """Root endpoint with API information"""
    return {
        "message": "HIPAA Compliant Medical Records API",
        "version": "1.0.0",
        "compliance": "HIPAA",
        "encryption": "AES-256-GCM",
        "audit_logging": True
    }

@app.get("/health")
async def health_check():
    """Health check endpoint"""
    return {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat(),
        "encryption_status": "active",
        "audit_logging": "active"
    }

@app.get("/patients/{patient_id}")
async def get_patient(
    patient_id: str,
    request: Request,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get patient data with HIPAA compliance"""
    
    # Check PHI access permission
    if not check_phi_access_permission(current_user, patient_id):
        log_phi_access(
            current_user.id,
            "PHI_ACCESS_DENIED",
            f"patient_{patient_id}",
            True,
            "Insufficient access level",
            request.client.host,
            db
        )
        raise HTTPException(status_code=403, detail="Insufficient access level for PHI")
    
    # Get patient from database
    patient = db.query(Patient).filter(Patient.patient_id == patient_id).first()
    if not patient:
        raise HTTPException(status_code=404, detail="Patient not found")
    
    # Check consent
    if not patient.consent_given:
        log_phi_access(
            current_user.id,
            "PHI_ACCESS_DENIED",
            f"patient_{patient_id}",
            True,
            "No consent given",
            request.client.host,
            db
        )
        raise HTTPException(status_code=403, detail="Patient consent required")
    
    # Decrypt PHI data
    try:
        decrypted_data = encryption.decrypt_phi(patient.encrypted_data)
    except Exception as e:
        logger.error(f"Failed to decrypt patient data: {e}")
        raise HTTPException(status_code=500, detail="Data decryption failed")
    
    # Log successful access
    log_phi_access(
        current_user.id,
        "PHI_ACCESS_SUCCESS",
        f"patient_{patient_id}",
        True,
        "Patient data retrieval",
        request.client.host,
        db
    )
    
    return {
        "patient_id": patient.patient_id,
        "medical_record_number": patient.medical_record_number,
        "data": decrypted_data,
        "access_level": patient.phi_access_level,
        "consent_given": patient.consent_given,
        "consent_date": patient.consent_date.isoformat() if patient.consent_date else None
    }

@app.post("/patients/{patient_id}/consent")
async def give_consent(
    patient_id: str,
    consent_request: ConsentRequest,
    request: Request,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Give consent for PHI access"""
    
    # Get patient
    patient = db.query(Patient).filter(Patient.patient_id == patient_id).first()
    if not patient:
        raise HTTPException(status_code=404, detail="Patient not found")
    
    # Update consent
    patient.consent_given = consent_request.consent_given
    patient.consent_date = datetime.utcnow()
    db.commit()
    
    # Log consent action
    log_phi_access(
        current_user.id,
        "CONSENT_GIVEN" if consent_request.consent_given else "CONSENT_WITHDRAWN",
        f"patient_{patient_id}",
        True,
        consent_request.access_reason,
        request.client.host,
        db
    )
    
    return {
        "message": "Consent updated successfully",
        "consent_given": consent_request.consent_given,
        "consent_date": patient.consent_date.isoformat()
    }

@app.post("/patients")
async def create_patient(
    patient_data: PatientData,
    request: Request,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Create new patient record with HIPAA compliance"""
    
    # Check if patient already exists
    existing_patient = db.query(Patient).filter(
        Patient.patient_id == patient_data.patient_id
    ).first()
    if existing_patient:
        raise HTTPException(status_code=400, detail="Patient already exists")
    
    # Encrypt PHI data
    phi_data = patient_data.dict()
    encrypted_data = encryption.encrypt_phi(phi_data)
    
    # Create patient record
    patient = Patient(
        patient_id=patient_data.patient_id,
        medical_record_number=patient_data.medical_record_number,
        encrypted_data=encrypted_data,
        phi_access_level='restricted',
        consent_given=False
    )
    
    db.add(patient)
    db.commit()
    db.refresh(patient)
    
    # Log patient creation
    log_phi_access(
        current_user.id,
        "PATIENT_CREATED",
        f"patient_{patient_data.patient_id}",
        True,
        "New patient record created",
        request.client.host,
        db
    )
    
    return {
        "message": "Patient created successfully",
        "patient_id": patient.patient_id,
        "medical_record_number": patient.medical_record_number,
        "phi_access_level": patient.phi_access_level
    }

@app.get("/audit-logs")
async def get_audit_logs(
    patient_id: Optional[str] = None,
    limit: int = 100,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get audit logs for HIPAA compliance monitoring"""
    
    query = db.query(AuditLog)
    
    if patient_id:
        query = query.filter(AuditLog.resource.like(f"%patient_{patient_id}%"))
    
    audit_logs = query.order_by(AuditLog.created_at.desc()).limit(limit).all()
    
    return {
        "audit_logs": [
            {
                "id": log.id,
                "user_id": log.user_id,
                "action": log.action,
                "resource": log.resource,
                "phi_accessed": log.phi_accessed,
                "access_reason": log.access_reason,
                "ip_address": log.ip_address,
                "created_at": log.created_at.isoformat()
            }
            for log in audit_logs
        ],
        "total": len(audit_logs)
    }

@app.get("/compliance-status")
async def get_compliance_status(
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get HIPAA compliance status"""
    
    # Get recent audit logs
    recent_logs = db.query(AuditLog).filter(
        AuditLog.created_at >= datetime.utcnow() - timedelta(days=30)
    ).all()
    
    # Calculate compliance metrics
    total_phi_access = len([log for log in recent_logs if log.phi_accessed])
    unauthorized_access = len([log for log in recent_logs if "DENIED" in log.action])
    
    compliance_score = max(0, 100 - (unauthorized_access / max(total_phi_access, 1)) * 100)
    
    return {
        "compliance_score": compliance_score,
        "total_phi_access_30_days": total_phi_access,
        "unauthorized_access_30_days": unauthorized_access,
        "encryption_status": "active",
        "audit_logging_status": "active",
        "last_updated": datetime.utcnow().isoformat()
    }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)

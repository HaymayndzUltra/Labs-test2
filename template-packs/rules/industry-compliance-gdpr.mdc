---
alwaysApply: true
description: "TAGS: [compliance,privacy,gdpr,data-protection,eu] | TRIGGERS: gdpr,privacy,consent,data-protection,eu,deletion,portability | SCOPE: {{PROJECT_NAME}} | DESCRIPTION: GDPR compliance requirements and implementation guidelines for handling EU personal data"
---

# GDPR Compliance Rules

## AI Persona
When this rule is active, you are a **Data Protection Officer (DPO)** with expertise in GDPR compliance, privacy by design, and personal data handling for EU citizens. You ensure all systems meet the requirements of the General Data Protection Regulation.

## Core GDPR Principles

### The 7 Key Principles:
1. **Lawfulness, fairness and transparency**
2. **Purpose limitation**
3. **Data minimisation**
4. **Accuracy**
5. **Storage limitation**
6. **Integrity and confidentiality**
7. **Accountability**

## Lawful Basis for Processing

### **[STRICT] Establish Lawful Basis**
```typescript
enum LawfulBasis {
  CONSENT = "consent",
  CONTRACT = "contract",
  LEGAL_OBLIGATION = "legal_obligation",
  VITAL_INTERESTS = "vital_interests",
  PUBLIC_TASK = "public_task",
  LEGITIMATE_INTERESTS = "legitimate_interests"
}

interface ProcessingActivity {
  id: string;
  purpose: string;
  dataCategories: string[];
  lawfulBasis: LawfulBasis;
  retention: string;
  recipients: string[];
  transfers: string[];
  documentation: string;
}

class GDPRProcessor {
  // Document lawful basis before any processing
  async processPersonalData(
    userId: string,
    data: any,
    activity: ProcessingActivity
  ): Promise<void> {
    // Verify lawful basis exists
    if (!await this.hasLawfulBasis(userId, activity)) {
      throw new Error("No lawful basis for processing");
    }
    
    // Log processing activity
    await this.logProcessingActivity(userId, activity);
    
    // Process data
    await this.performProcessing(data);
  }
}
```

## Consent Management

### **[STRICT] Valid Consent Implementation**
```typescript
interface ConsentRecord {
  userId: string;
  timestamp: Date;
  purpose: string;
  version: string;
  method: "explicit" | "implicit"; // Must be explicit for GDPR
  withdrawable: boolean; // Always true under GDPR
  text: string; // Exact consent text shown
  ipAddress: string;
  userAgent: string;
}

class ConsentManager {
  // Consent must be freely given, specific, informed, and unambiguous
  async obtainConsent(
    userId: string,
    purpose: string,
    consentText: string
  ): Promise<ConsentRecord> {
    // Verify consent is explicit
    if (!this.isExplicitConsent(consentText)) {
      throw new Error("Consent must be explicit and unambiguous");
    }
    
    // No pre-ticked boxes allowed
    if (this.hasPreTickedBoxes()) {
      throw new Error("Pre-ticked consent boxes are not allowed");
    }
    
    // Record consent with full audit trail
    const consent: ConsentRecord = {
      userId,
      timestamp: new Date(),
      purpose,
      version: this.getCurrentConsentVersion(),
      method: "explicit",
      withdrawable: true,
      text: consentText,
      ipAddress: this.getUserIP(),
      userAgent: this.getUserAgent()
    };
    
    await this.storeConsent(consent);
    return consent;
  }
  
  // Withdrawal must be as easy as giving consent
  async withdrawConsent(userId: string, purpose: string): Promise<void> {
    await this.markConsentWithdrawn(userId, purpose);
    await this.stopProcessing(userId, purpose);
    await this.notifyWithdrawal(userId, purpose);
  }
}
```

### **[STRICT] Cookie Consent**
```typescript
class CookieConsent {
  // Strictly necessary cookies don't need consent
  // All others do
  
  readonly cookieCategories = {
    necessary: {
      requiresConsent: false,
      description: "Essential for site functionality"
    },
    functional: {
      requiresConsent: true,
      description: "Remember user preferences"
    },
    analytics: {
      requiresConsent: true,
      description: "Understand site usage"
    },
    marketing: {
      requiresConsent: true,
      description: "Personalized advertisements"
    }
  };
  
  async setCookie(
    name: string,
    value: string,
    category: keyof typeof this.cookieCategories
  ): Promise<void> {
    const categoryConfig = this.cookieCategories[category];
    
    if (categoryConfig.requiresConsent) {
      const hasConsent = await this.hasConsentForCategory(category);
      if (!hasConsent) {
        console.log(`No consent for ${category} cookies`);
        return;
      }
    }
    
    // Set cookie with appropriate settings
    document.cookie = `${name}=${value}; SameSite=Strict; Secure`;
  }
}
```

## Individual Rights Implementation

### **[STRICT] Right to Access (Article 15)**
```python
from datetime import datetime
from typing import Dict, List, Optional
import json

class DataSubjectAccess:
    """Handle data subject access requests"""
    
    def process_access_request(self, user_id: str) -> Dict:
        """Process GDPR Article 15 access request"""
        
        # Verify identity first
        if not self.verify_identity(user_id):
            raise ValueError("Identity verification failed")
        
        # Collect all personal data
        personal_data = {
            "request_date": datetime.utcnow().isoformat(),
            "user_id": user_id,
            "personal_information": self.get_personal_info(user_id),
            "processing_purposes": self.get_processing_purposes(user_id),
            "data_categories": self.get_data_categories(user_id),
            "recipients": self.get_data_recipients(user_id),
            "retention_periods": self.get_retention_periods(user_id),
            "data_sources": self.get_data_sources(user_id),
            "automated_decisions": self.get_automated_decisions(user_id),
            "international_transfers": self.get_transfers(user_id),
            "consent_records": self.get_consent_history(user_id)
        }
        
        # Include actual data
        personal_data["data"] = self.export_all_user_data(user_id)
        
        # Log access request
        self.log_access_request(user_id)
        
        return personal_data
    
    def export_all_user_data(self, user_id: str) -> Dict:
        """Export all personal data in structured format"""
        return {
            "profile": self.get_profile_data(user_id),
            "activity": self.get_activity_data(user_id),
            "preferences": self.get_preferences(user_id),
            "communications": self.get_communications(user_id),
            "third_party_data": self.get_third_party_data(user_id)
        }
```

### **[STRICT] Right to Rectification (Article 16)**
```python
class DataRectification:
    """Handle data correction requests"""
    
    def rectify_data(
        self,
        user_id: str,
        field: str,
        old_value: str,
        new_value: str,
        reason: str
    ) -> bool:
        """Process rectification request"""
        
        # Verify the change is valid
        if not self.validate_change(field, new_value):
            raise ValueError(f"Invalid value for field {field}")
        
        # Create audit trail
        rectification_record = {
            "user_id": user_id,
            "timestamp": datetime.utcnow(),
            "field": field,
            "old_value": old_value,
            "new_value": new_value,
            "reason": reason,
            "verified": self.verify_accuracy(new_value)
        }
        
        # Update the data
        self.update_user_data(user_id, field, new_value)
        
        # Notify data recipients
        recipients = self.get_data_recipients_for_field(field)
        for recipient in recipients:
            self.notify_rectification(recipient, rectification_record)
        
        # Log the rectification
        self.log_rectification(rectification_record)
        
        return True
```

### **[STRICT] Right to Erasure / Right to be Forgotten (Article 17)**
```python
class DataErasure:
    """Handle data deletion requests"""
    
    def process_erasure_request(
        self,
        user_id: str,
        reason: str
    ) -> Dict[str, any]:
        """Process right to be forgotten request"""
        
        # Check if erasure is allowed
        erasure_check = self.can_erase_data(user_id)
        
        if not erasure_check["can_erase"]:
            return {
                "status": "denied",
                "reason": erasure_check["denial_reason"],
                "legal_basis": erasure_check["legal_basis"]
            }
        
        # Identify all data to be erased
        data_inventory = self.get_erasure_inventory(user_id)
        
        # Perform erasure
        erasure_result = {
            "user_id": user_id,
            "timestamp": datetime.utcnow(),
            "data_erased": [],
            "data_retained": [],
            "anonymized_data": []
        }
        
        for data_item in data_inventory:
            if data_item["must_retain"]:
                # Anonymize instead of delete if legal obligation
                self.anonymize_data(data_item)
                erasure_result["anonymized_data"].append(data_item["type"])
            else:
                # Permanently delete
                self.delete_data(data_item)
                erasure_result["data_erased"].append(data_item["type"])
        
        # Remove from all backups (within reasonable time)
        self.schedule_backup_removal(user_id)
        
        # Notify third parties
        self.notify_erasure_to_recipients(user_id)
        
        # Create certificate of erasure
        certificate = self.generate_erasure_certificate(erasure_result)
        
        return {
            "status": "completed",
            "certificate": certificate,
            "summary": erasure_result
        }
    
    def can_erase_data(self, user_id: str) -> Dict[str, any]:
        """Check if data can be legally erased"""
        
        # Legal obligations to retain data
        if self.has_legal_retention_requirement(user_id):
            return {
                "can_erase": False,
                "denial_reason": "Legal retention requirement",
                "legal_basis": "Tax law requires 7-year retention"
            }
        
        # Ongoing contract
        if self.has_active_contract(user_id):
            return {
                "can_erase": False,
                "denial_reason": "Active contract requires data",
                "legal_basis": "Contract performance"
            }
        
        return {"can_erase": True}
```

### **[STRICT] Right to Data Portability (Article 20)**
```typescript
class DataPortability {
  // Data must be provided in structured, commonly used, machine-readable format
  
  async exportUserData(userId: string, format: "json" | "csv" | "xml"): Promise<File> {
    // Collect all data provided by the user
    const userData = await this.collectUserProvidedData(userId);
    
    // Include observed data (if based on consent/contract)
    const observedData = await this.collectObservedData(userId);
    
    // Format data appropriately
    let exportData: string;
    let mimeType: string;
    
    switch (format) {
      case "json":
        exportData = JSON.stringify({
          exportDate: new Date().toISOString(),
          userData,
          observedData
        }, null, 2);
        mimeType = "application/json";
        break;
        
      case "csv":
        exportData = this.convertToCSV(userData, observedData);
        mimeType = "text/csv";
        break;
        
      case "xml":
        exportData = this.convertToXML(userData, observedData);
        mimeType = "application/xml";
        break;
    }
    
    // Create downloadable file
    return new File([exportData], `gdpr-export-${userId}.${format}`, {
      type: mimeType
    });
  }
  
  // Direct transfer to another controller
  async transferToController(
    userId: string,
    targetController: string,
    apiEndpoint: string
  ): Promise<void> {
    const data = await this.exportUserData(userId, "json");
    
    // Secure transfer with encryption
    await this.secureTransfer(apiEndpoint, data, {
      encryption: "AES-256",
      authentication: "OAuth2"
    });
  }
}
```

## Privacy by Design

### **[STRICT] Data Minimization**
```typescript
class DataMinimization {
  // Only collect data that is necessary
  
  validateDataCollection(
    purpose: string,
    requestedFields: string[]
  ): string[] {
    const necessaryFields = this.getNecessaryFields(purpose);
    
    // Remove unnecessary fields
    const allowedFields = requestedFields.filter(field => 
      necessaryFields.includes(field)
    );
    
    if (allowedFields.length < requestedFields.length) {
      console.warn("Removed unnecessary fields:", 
        requestedFields.filter(f => !allowedFields.includes(f))
      );
    }
    
    return allowedFields;
  }
  
  // Example: User registration
  getNecessaryFields(purpose: string): string[] {
    switch (purpose) {
      case "registration":
        return ["email", "password"]; // Not name, address, phone, etc.
      case "newsletter":
        return ["email"]; // Only email needed
      case "purchase":
        return ["email", "shipping_address", "payment_method"];
      default:
        return [];
    }
  }
}
```

### **[STRICT] Data Retention**
```python
class DataRetention:
    """Implement data retention policies"""
    
    retention_policies = {
        "user_account": {"period": "active+30days", "reason": "Account recovery"},
        "transaction": {"period": "7years", "reason": "Tax law"},
        "marketing": {"period": "2years", "reason": "Consent duration"},
        "logs": {"period": "90days", "reason": "Security monitoring"},
        "cookies": {"period": "1year", "reason": "User preference"}
    }
    
    def apply_retention_policy(self):
        """Delete data past retention period"""
        for data_type, policy in self.retention_policies.items():
            expired_data = self.get_expired_data(data_type, policy["period"])
            
            for record in expired_data:
                # Log deletion for compliance
                self.log_deletion(record, policy["reason"])
                
                # Anonymize if needed for statistics
                if self.needed_for_statistics(record):
                    self.anonymize_record(record)
                else:
                    self.delete_record(record)
```

## Data Protection Impact Assessment (DPIA)

### **[STRICT] When DPIA is Required**
```python
class DPIAAssessment:
    """Data Protection Impact Assessment"""
    
    def is_dpia_required(self, processing_activity: Dict) -> bool:
        """Determine if DPIA is required"""
        
        # Systematic and extensive evaluation
        if processing_activity.get("profiling") or processing_activity.get("automated_decisions"):
            return True
        
        # Large scale processing of special categories
        if processing_activity.get("special_categories") and processing_activity.get("large_scale"):
            return True
        
        # Systematic monitoring of public areas
        if processing_activity.get("public_monitoring"):
            return True
        
        # Innovative technology
        if processing_activity.get("new_technology"):
            return True
        
        return False
    
    def conduct_dpia(self, project: str) -> Dict:
        """Conduct DPIA"""
        dpia = {
            "project": project,
            "date": datetime.utcnow(),
            "description": self.describe_processing(),
            "necessity": self.assess_necessity(),
            "proportionality": self.assess_proportionality(),
            "risks": self.identify_risks(),
            "measures": self.identify_measures(),
            "residual_risks": self.assess_residual_risks(),
            "consultation_needed": False
        }
        
        # High risk requires consultation with supervisory authority
        if dpia["residual_risks"]["level"] == "high":
            dpia["consultation_needed"] = True
        
        return dpia
```

## Security Measures

### **[STRICT] Pseudonymization and Encryption**
```python
import hashlib
import secrets
from cryptography.fernet import Fernet

class GDPRSecurity:
    """Security measures for GDPR compliance"""
    
    def pseudonymize_data(self, personal_data: Dict, fields: List[str]) -> Dict:
        """Replace identifiers with pseudonyms"""
        pseudonymized = personal_data.copy()
        mapping = {}
        
        for field in fields:
            if field in pseudonymized:
                # Generate consistent pseudonym
                pseudonym = self.generate_pseudonym(pseudonymized[field])
                mapping[pseudonym] = pseudonymized[field]
                pseudonymized[field] = pseudonym
        
        # Store mapping securely (separate from data)
        self.store_pseudonym_mapping(mapping)
        
        return pseudonymized
    
    def encrypt_personal_data(self, data: str) -> str:
        """Encrypt personal data at rest"""
        key = self.get_or_create_key()
        f = Fernet(key)
        return f.encrypt(data.encode()).decode()
    
    def implement_access_controls(self):
        """Technical and organizational measures"""
        measures = {
            "encryption": "AES-256 for data at rest",
            "access_control": "Role-based with least privilege",
            "monitoring": "Real-time anomaly detection",
            "backup": "Encrypted backups with versioning",
            "incident_response": "24-hour breach notification",
            "training": "Annual GDPR training for all staff"
        }
        return measures
```

## Breach Notification

### **[STRICT] 72-Hour Notification Rule**
```python
class BreachNotification:
    """GDPR breach notification requirements"""
    
    def handle_data_breach(self, breach_details: Dict) -> Dict:
        """Handle data breach per GDPR requirements"""
        
        breach_record = {
            "id": self.generate_breach_id(),
            "discovered": datetime.utcnow(),
            "description": breach_details["description"],
            "data_affected": breach_details["data_types"],
            "individuals_affected": breach_details["user_count"],
            "likely_consequences": self.assess_consequences(breach_details),
            "measures_taken": breach_details["immediate_actions"],
            "notification_required": True
        }
        
        # Assess risk to individuals
        risk_level = self.assess_risk_level(breach_record)
        breach_record["risk_level"] = risk_level
        
        # Notify supervisory authority within 72 hours
        if risk_level != "no_risk":
            deadline = breach_record["discovered"] + timedelta(hours=72)
            self.notify_supervisory_authority(breach_record, deadline)
        
        # Notify individuals if high risk
        if risk_level == "high":
            self.notify_affected_individuals(breach_record)
        
        # Document everything
        self.document_breach(breach_record)
        
        return breach_record
    
    def notify_supervisory_authority(self, breach: Dict, deadline: datetime):
        """Notify relevant data protection authority"""
        notification = {
            "breach_id": breach["id"],
            "controller": self.get_controller_details(),
            "dpo_contact": self.get_dpo_contact(),
            "breach_description": breach["description"],
            "timeline": {
                "occurred": breach.get("occurred_time", "unknown"),
                "discovered": breach["discovered"],
                "notified": datetime.utcnow()
            },
            "categories_of_data": breach["data_affected"],
            "approximate_individuals": breach["individuals_affected"],
            "likely_consequences": breach["likely_consequences"],
            "measures_taken": breach["measures_taken"],
            "proposed_measures": self.get_proposed_measures(breach)
        }
        
        # Send to appropriate authority based on location
        self.send_to_authority(notification)
```

## International Transfers

### **[STRICT] Transfer Safeguards**
```typescript
class InternationalTransfers {
  // Ensure adequate protection for transfers outside EEA
  
  async transferData(
    data: any,
    destination: string,
    recipient: string
  ): Promise<void> {
    // Check if destination has adequacy decision
    if (this.hasAdequacyDecision(destination)) {
      await this.performTransfer(data, recipient);
      return;
    }
    
    // Otherwise need appropriate safeguards
    const safeguards = await this.getSafeguards(recipient);
    
    if (safeguards.type === "SCC") { // Standard Contractual Clauses
      if (!this.validateSCC(safeguards)) {
        throw new Error("Invalid Standard Contractual Clauses");
      }
    } else if (safeguards.type === "BCR") { // Binding Corporate Rules
      if (!this.validateBCR(safeguards)) {
        throw new Error("Invalid Binding Corporate Rules");
      }
    } else {
      // Need explicit consent with risks explained
      const consent = await this.getExplicitTransferConsent(
        data.userId,
        destination,
        this.explainRisks(destination)
      );
      
      if (!consent) {
        throw new Error("No valid basis for international transfer");
      }
    }
    
    // Log transfer
    await this.logInternationalTransfer(data, destination, safeguards);
    
    // Perform transfer
    await this.performTransfer(data, recipient);
  }
}
```

## Compliance Checklist

### **[STRICT] Development Checklist**
```typescript
interface GDPRChecklist {
  // Before collecting any personal data
  dataCollection: {
    hasLawfulBasis: boolean;
    isPurposeDocumented: boolean;
    isMinimumNecessary: boolean;
    hasPrivacyNotice: boolean;
    hasConsentMechanism: boolean;
  };
  
  // Individual rights implementation
  rights: {
    accessRequestHandler: boolean;
    rectificationProcess: boolean;
    erasureProcess: boolean;
    portabilityExport: boolean;
    objectionHandling: boolean;
    automatedDecisionOptOut: boolean;
  };
  
  // Security measures
  security: {
    encryptionAtRest: boolean;
    encryptionInTransit: boolean;
    accessControls: boolean;
    auditLogging: boolean;
    incidentResponse: boolean;
    regularTesting: boolean;
  };
  
  // Documentation
  documentation: {
    recordsOfProcessing: boolean;
    privacyPolicy: boolean;
    dpiaWhenRequired: boolean;
    dataRetentionPolicy: boolean;
    vendorAgreements: boolean;
    consentRecords: boolean;
  };
}
```

## Red Flags - Common GDPR Violations

1. **No clear privacy notice** - Must inform users clearly
2. **Pre-ticked consent boxes** - Consent must be explicit
3. **Difficult withdrawal process** - Must be as easy as giving consent
4. **Excessive data collection** - Only collect what's necessary
5. **No retention limits** - Must delete when no longer needed
6. **Ignoring access requests** - 1-month response deadline
7. **No breach notification** - 72-hour deadline
8. **Transfers without safeguards** - Need adequate protection
9. **No age verification** - Special rules for children under 16
10. **Dark patterns** - Manipulative UX for consent is illegal

## References

- [GDPR Official Text](https://gdpr-info.eu/)
- [European Data Protection Board Guidelines](https://edpb.europa.eu/edpb_en)
- [ICO GDPR Guide](https://ico.org.uk/for-organisations/guide-to-data-protection/guide-to-the-general-data-protection-regulation-gdpr/)
- [GDPR Enforcement Tracker](https://www.enforcementtracker.com/)
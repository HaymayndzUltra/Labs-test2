---
alwaysApply: true
description: "TAGS: [compliance,security,pci,payment] | TRIGGERS: pci,payment,cardholder,security,compliance,dss | SCOPE: {{PROJECT_NAME}} | DESCRIPTION: PCI DSS compliance requirements and implementation guidelines for payment processing systems"
---

# PCI DSS Compliance Rules

## AI Persona
When this rule is active, you are a **PCI DSS Compliance Engineer** with expertise in payment card security, cardholder data protection, and secure payment processing systems. You ensure all code and systems meet Payment Card Industry Data Security Standards.

## Core PCI DSS Principles

### The PCI DSS requires:
1. **Build and maintain secure networks and systems**
2. **Protect cardholder data**
3. **Maintain a vulnerability management program**
4. **Implement strong access control measures**
5. **Regularly monitor and test networks**
6. **Maintain an information security policy**

## Required Controls [CRITICAL]

### 1. Cardholder Data Protection
```python
import cryptography.fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC

class PCIDataProtection:
    def __init__(self):
        self.encryption_key = self.generate_encryption_key()
    
    def encrypt_cardholder_data(self, pan, expiry=None):
        """Encrypt PAN with AES-256 for storage"""
        # Never store full PAN in logs or temporary variables
        if not self.validate_pan(pan):
            raise ValueError("Invalid PAN format")
        
        encrypted_pan = self.encrypt_sensitive_data(pan)
        
        # Mask PAN for display (show only last 4 digits)
        masked_pan = self.mask_pan(pan)
        
        return {
            'encrypted_pan': encrypted_pan,
            'masked_pan': masked_pan,
            'token': self.generate_token(pan)
        }
    
    def mask_pan(self, pan):
        """Mask PAN showing only last 4 digits"""
        if len(pan) < 4:
            return "****"
        return "*" * (len(pan) - 4) + pan[-4:]
```

### 2. Network Security
```python
# Web Application Firewall configuration
WAF_RULES = {
    'sql_injection_protection': True,
    'xss_protection': True,
    'rate_limiting': {
        'requests_per_minute': 100,
        'burst_limit': 20
    },
    'ip_whitelist': ['192.168.1.0/24'],  # Only allow trusted networks
    'tls_version': '1.2_minimum'
}

# Network segmentation for CDE
NETWORK_SEGMENTS = {
    'cardholder_data_environment': {
        'subnet': '10.0.1.0/24',
        'firewall_rules': 'restrictive',
        'monitoring': 'enhanced'
    },
    'public_facing': {
        'subnet': '10.0.2.0/24',
        'firewall_rules': 'standard',
        'monitoring': 'standard'
    }
}
```

### 3. Tokenization Implementation
```python
import secrets
import hashlib

class PCITokenization:
    def __init__(self):
        self.token_vault = {}  # In production, use secure token vault
    
    def tokenize_pan(self, pan):
        """Replace PAN with non-sensitive token"""
        # Validate PAN format
        if not self.luhn_check(pan):
            raise ValueError("Invalid PAN")
        
        # Generate cryptographically secure token
        token = self.generate_secure_token()
        
        # Store mapping in secure vault (not in application database)
        self.store_token_mapping(token, pan)
        
        return token
    
    def detokenize(self, token, authorized_user):
        """Retrieve PAN from token (authorized access only)"""
        if not self.verify_authorization(authorized_user):
            raise PermissionError("Unauthorized detokenization attempt")
        
        # Log access attempt
        self.log_detokenization_access(token, authorized_user)
        
        return self.retrieve_pan_from_vault(token)
```

### 4. Access Control and Authentication
```python
from functools import wraps
import time

def pci_access_control(required_role=None):
    """PCI-compliant access control decorator"""
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            user = get_current_user()
            
            # Multi-factor authentication check
            if not user.mfa_verified:
                return {'error': 'MFA required for CDE access'}, 401
            
            # Role-based access control
            if required_role and not user.has_role(required_role):
                log_unauthorized_access_attempt(user.id, f.__name__)
                return {'error': 'Insufficient privileges'}, 403
            
            # Log authorized access
            log_cardholder_data_access(user.id, f.__name__, time.time())
            
            return f(*args, **kwargs)
        return decorated_function
    return decorator

@app.route('/api/payment/process', methods=['POST'])
@pci_access_control(required_role='payment_processor')
def process_payment():
    """PCI-secured payment processing endpoint"""
    pass
```

### 5. Vulnerability Management
```python
# Automated security scanning configuration
SECURITY_SCANS = {
    'vulnerability_scan': {
        'frequency': 'quarterly',
        'scope': 'all_cde_systems',
        'vendor': 'approved_scanning_vendor'
    },
    'penetration_test': {
        'frequency': 'annually',
        'scope': 'network_and_applications',
        'tester': 'qualified_security_assessor'
    },
    'code_review': {
        'frequency': 'every_release',
        'tools': ['static_analysis', 'dynamic_analysis'],
        'focus': 'payment_processing_code'
    }
}
```

## Technical Implementation

### Database Security
```sql
-- PCI-compliant cardholder data table
CREATE TABLE encrypted_cardholder_data (
    id SERIAL PRIMARY KEY,
    token VARCHAR(255) UNIQUE NOT NULL,
    encrypted_data BYTEA NOT NULL,  -- AES-256 encrypted PAN
    encryption_key_id VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    accessed_by VARCHAR(255),
    last_accessed TIMESTAMP,
    -- PCI audit fields
    pci_dss_version VARCHAR(10) NOT NULL DEFAULT '4.0',
    compliance_validated BOOLEAN DEFAULT FALSE,
    retention_period INTEGER DEFAULT 365  -- days
);

-- Never store sensitive authentication data
-- NO CVV, NO PIN, NO magnetic stripe data

-- Audit trigger for cardholder data access
CREATE TRIGGER pci_audit_trigger
    AFTER SELECT OR INSERT OR UPDATE OR DELETE ON encrypted_cardholder_data
    FOR EACH ROW EXECUTE FUNCTION log_pci_audit_trail();
```

### Logging and Monitoring
```python
import json
import syslog
from datetime import datetime

class PCIAuditLogger:
    def __init__(self):
        self.siem_endpoint = os.getenv('SIEM_ENDPOINT')
    
    def log_cardholder_data_access(self, user_id, action, result):
        """Log all cardholder data access attempts"""
        audit_event = {
            'timestamp': datetime.utcnow().isoformat(),
            'event_type': 'cardholder_data_access',
            'user_id': user_id,
            'action': action,
            'result': result,
            'source_ip': request.remote_addr,
            'user_agent': request.headers.get('User-Agent'),
            'session_id': session.get('session_id'),
            'pci_dss_requirement': '10.2.1'
        }
        
        # Send to SIEM for correlation
        self.send_to_siem(audit_event)
        
        # Local secure logging
        syslog.syslog(syslog.LOG_INFO, json.dumps(audit_event))
```

## CI/CD Gates

### Security Validation Pipeline
```yaml
# .github/workflows/pci-compliance.yml
name: PCI DSS Compliance Check
on: [push, pull_request]
jobs:
  pci-validation:
    runs-on: ubuntu-latest
    steps:
      - name: Secret Detection
        run: |
          # Scan for hardcoded PANs, API keys, certificates
          python scripts/scan_for_secrets.py
          
      - name: Dependency Vulnerability Scan
        run: |
          # Check for known vulnerabilities in dependencies
          npm audit --audit-level high
          pip-audit
          
      - name: Static Code Analysis
        run: |
          # SAST scanning focused on payment processing code
          semgrep --config=pci-rules .
          
      - name: PCI DSS Requirement Validation
        run: |
          python scripts/validate_pci_requirements.py
```

### Deployment Gates
- Zero critical vulnerabilities allowed
- No sensitive data in logs or configuration
- Encryption validation for all cardholder data
- Network segmentation verification
- Access control testing completion

## Testing Requirements

### Security Test Cases
```python
import pytest
from unittest.mock import patch

class TestPCICompliance:
    def test_pan_encryption_strength(self):
        """Verify PAN encryption uses AES-256"""
        # Test implementation
        pass
        
    def test_cardholder_data_masking(self):
        """Verify PAN masking in all outputs"""
        # Test implementation
        pass
        
    def test_network_segmentation(self):
        """Verify CDE network isolation"""
        # Test implementation
        pass
        
    def test_access_control_enforcement(self):
        """Verify role-based access controls"""
        # Test implementation
        pass
        
    def test_audit_logging_completeness(self):
        """Verify all required events are logged"""
        # Test implementation
        pass
```

## Key Implementation Guidelines

1. **Never store sensitive authentication data** (CVV, PIN, magnetic stripe)
2. **Encrypt all cardholder data** using strong cryptography (AES-256)
3. **Implement tokenization** to minimize cardholder data storage
4. **Maintain detailed audit logs** for all cardholder data access
5. **Regular security testing** with quarterly scans and annual penetration tests

## Emergency Response

### Security Incident Procedures
1. **Immediate containment** of affected payment systems
2. **Assessment of data exposure** and potential compromise
3. **Notification** to payment brands and acquiring bank
4. **Forensic investigation** by qualified security assessor
5. **Remediation and validation** of security controls

### Compliance Violations
- Document all violations and root causes
- Implement immediate remediation measures
- Report to payment card brands if required
- Enhance security controls to prevent recurrence
- Validate remediation through independent testing

Refer to PCI DSS v4.0, PCI SSC guidance documents, and payment brand security requirements for complete implementation guidance.

#!/usr/bin/env python3
"""
Intelligent Tech Stack Selector
Generated by Enhanced Client Project Scaffold

This module provides intelligent technology stack selection based on
industry requirements, compliance needs, and performance criteria.
"""

import json
import yaml
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass, asdict
from enum import Enum
import logging
from pathlib import Path
import re
from datetime import datetime

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class IndustryType(Enum):
    HEALTHCARE = "healthcare"
    FINANCE = "finance"
    ECOMMERCE = "ecommerce"
    ENTERPRISE_SAAS = "enterprise_saas"
    EDUCATION = "education"
    GOVERNMENT = "government"
    MANUFACTURING = "manufacturing"
    RETAIL = "retail"
    MEDIA = "media"
    GAMING = "gaming"
    IOT = "iot"
    BLOCKCHAIN = "blockchain"
    AI_ML = "ai_ml"
    GENERAL = "general"

class ComplianceRequirement(Enum):
    HIPAA = "hipaa"
    SOX = "sox"
    PCI_DSS = "pci_dss"
    GDPR = "gdpr"
    CCPA = "ccpa"
    SOC2 = "soc2"
    ISO27001 = "iso27001"
    FERPA = "ferpa"
    COPPA = "coppa"
    NONE = "none"

class PerformanceTier(Enum):
    BASIC = "basic"
    STANDARD = "standard"
    HIGH_PERFORMANCE = "high_performance"
    ENTERPRISE = "enterprise"

class ScalabilityRequirement(Enum):
    LOW = "low"          # < 1K users
    MEDIUM = "medium"    # 1K - 100K users
    HIGH = "high"        # 100K - 1M users
    MASSIVE = "massive"  # > 1M users

@dataclass
class TechStackComponent:
    """Represents a technology stack component"""
    name: str
    category: str  # frontend, backend, database, cache, message_queue, etc.
    technology: str
    version: str
    description: str
    pros: List[str]
    cons: List[str]
    performance_score: int  # 1-10
    security_score: int    # 1-10
    scalability_score: int # 1-10
    learning_curve: int    # 1-10 (1 = easy, 10 = hard)
    community_support: int # 1-10
    enterprise_ready: bool
    compliance_support: List[ComplianceRequirement]
    industry_suitability: List[IndustryType]
    dependencies: List[str]
    alternatives: List[str]
    cost_tier: str  # free, low, medium, high, enterprise

@dataclass
class TechStackRecommendation:
    """Represents a complete technology stack recommendation"""
    frontend: List[TechStackComponent]
    backend: List[TechStackComponent]
    database: List[TechStackComponent]
    cache: List[TechStackComponent]
    message_queue: List[TechStackComponent]
    search: List[TechStackComponent]
    monitoring: List[TechStackComponent]
    security: List[TechStackComponent]
    deployment: List[TechStackComponent]
    overall_score: int
    compliance_score: int
    performance_score: int
    scalability_score: int
    cost_estimate: str
    complexity_level: str
    recommended_for: List[str]

class IntelligentTechStackSelector:
    """Intelligent technology stack selector based on requirements"""
    
    def __init__(self, config_path: Optional[str] = None):
        self.config_path = config_path or Path(__file__).parent / "tech-stack-config.yaml"
        self.tech_components = {}
        self.industry_patterns = {}
        self.compliance_requirements = {}
        self.load_configuration()
    
    def load_configuration(self):
        """Load technology stack configuration from YAML file"""
        try:
            if self.config_path.exists():
                with open(self.config_path, 'r') as f:
                    config = yaml.safe_load(f)
                    self.tech_components = config.get('tech_components', {})
                    self.industry_patterns = config.get('industry_patterns', {})
                    self.compliance_requirements = config.get('compliance_requirements', {})
            else:
                self.initialize_default_configuration()
                self.save_configuration()
        except Exception as e:
            logger.error(f"Failed to load configuration: {e}")
            self.initialize_default_configuration()
    
    def initialize_default_configuration(self):
        """Initialize default technology stack configuration"""
        self.tech_components = {
            "frontend": {
                "react": {
                    "name": "React",
                    "category": "frontend",
                    "technology": "react",
                    "version": "18.2.0",
                    "description": "A JavaScript library for building user interfaces",
                    "pros": ["Large ecosystem", "Strong community", "Flexible", "Good performance"],
                    "cons": ["Steep learning curve", "Rapid changes", "Complex state management"],
                    "performance_score": 8,
                    "security_score": 7,
                    "scalability_score": 9,
                    "learning_curve": 6,
                    "community_support": 10,
                    "enterprise_ready": True,
                    "compliance_support": ["GDPR", "CCPA", "SOC2"],
                    "industry_suitability": ["healthcare", "finance", "ecommerce", "enterprise_saas"],
                    "dependencies": ["nodejs", "npm"],
                    "alternatives": ["vue", "angular", "svelte"],
                    "cost_tier": "free"
                },
                "vue": {
                    "name": "Vue.js",
                    "category": "frontend",
                    "technology": "vue",
                    "version": "3.3.0",
                    "description": "Progressive JavaScript framework",
                    "pros": ["Easy to learn", "Good documentation", "Flexible", "Lightweight"],
                    "cons": ["Smaller ecosystem", "Less enterprise adoption", "Limited tooling"],
                    "performance_score": 8,
                    "security_score": 7,
                    "scalability_score": 8,
                    "learning_curve": 4,
                    "community_support": 8,
                    "enterprise_ready": True,
                    "compliance_support": ["GDPR", "CCPA"],
                    "industry_suitability": ["ecommerce", "general"],
                    "dependencies": ["nodejs", "npm"],
                    "alternatives": ["react", "angular", "svelte"],
                    "cost_tier": "free"
                },
                "angular": {
                    "name": "Angular",
                    "category": "frontend",
                    "technology": "angular",
                    "version": "16.0.0",
                    "description": "Platform for building mobile and desktop web applications",
                    "pros": ["Full framework", "TypeScript support", "Enterprise features", "Strong typing"],
                    "cons": ["Steep learning curve", "Heavy", "Complex", "Opinionated"],
                    "performance_score": 7,
                    "security_score": 8,
                    "scalability_score": 9,
                    "learning_curve": 8,
                    "community_support": 9,
                    "enterprise_ready": True,
                    "compliance_support": ["GDPR", "CCPA", "SOC2", "HIPAA"],
                    "industry_suitability": ["healthcare", "finance", "enterprise_saas", "government"],
                    "dependencies": ["nodejs", "npm"],
                    "alternatives": ["react", "vue", "svelte"],
                    "cost_tier": "free"
                }
            },
            "backend": {
                "nodejs": {
                    "name": "Node.js",
                    "category": "backend",
                    "technology": "nodejs",
                    "version": "20.0.0",
                    "description": "JavaScript runtime for server-side development",
                    "pros": ["Fast development", "Large ecosystem", "JSON native", "Real-time capabilities"],
                    "cons": ["Single-threaded", "Memory intensive", "Callback hell", "Not CPU intensive"],
                    "performance_score": 7,
                    "security_score": 6,
                    "scalability_score": 8,
                    "learning_curve": 5,
                    "community_support": 10,
                    "enterprise_ready": True,
                    "compliance_support": ["GDPR", "CCPA", "SOC2"],
                    "industry_suitability": ["ecommerce", "general", "media", "gaming"],
                    "dependencies": [],
                    "alternatives": ["python", "java", "go", "csharp"],
                    "cost_tier": "free"
                },
                "python": {
                    "name": "Python",
                    "category": "backend",
                    "technology": "python",
                    "version": "3.11.0",
                    "description": "High-level programming language with extensive libraries",
                    "pros": ["Easy to learn", "Extensive libraries", "Data science", "AI/ML support"],
                    "cons": ["Slower execution", "GIL limitations", "Memory usage", "Version fragmentation"],
                    "performance_score": 6,
                    "security_score": 7,
                    "scalability_score": 7,
                    "learning_curve": 3,
                    "community_support": 10,
                    "enterprise_ready": True,
                    "compliance_support": ["GDPR", "CCPA", "SOC2", "HIPAA"],
                    "industry_suitability": ["healthcare", "finance", "ai_ml", "education", "general"],
                    "dependencies": [],
                    "alternatives": ["nodejs", "java", "go", "csharp"],
                    "cost_tier": "free"
                },
                "java": {
                    "name": "Java",
                    "category": "backend",
                    "technology": "java",
                    "version": "17.0.0",
                    "description": "Object-oriented programming language for enterprise applications",
                    "pros": ["Enterprise ready", "Strong typing", "Mature ecosystem", "Cross-platform"],
                    "cons": ["Verbose", "Memory intensive", "Slow startup", "Complex configuration"],
                    "performance_score": 8,
                    "security_score": 9,
                    "scalability_score": 9,
                    "learning_curve": 7,
                    "community_support": 9,
                    "enterprise_ready": True,
                    "compliance_support": ["GDPR", "CCPA", "SOC2", "HIPAA", "SOX"],
                    "industry_suitability": ["healthcare", "finance", "enterprise_saas", "government"],
                    "dependencies": ["jvm"],
                    "alternatives": ["python", "csharp", "go"],
                    "cost_tier": "free"
                },
                "go": {
                    "name": "Go",
                    "category": "backend",
                    "technology": "go",
                    "version": "1.21.0",
                    "description": "Statically typed compiled language for concurrent programming",
                    "pros": ["Fast compilation", "Concurrent", "Memory efficient", "Simple syntax"],
                    "cons": ["Limited libraries", "No generics (until 1.18)", "Smaller ecosystem", "Learning curve"],
                    "performance_score": 9,
                    "security_score": 8,
                    "scalability_score": 10,
                    "learning_curve": 6,
                    "community_support": 7,
                    "enterprise_ready": True,
                    "compliance_support": ["GDPR", "CCPA", "SOC2"],
                    "industry_suitability": ["finance", "iot", "blockchain", "general"],
                    "dependencies": [],
                    "alternatives": ["nodejs", "python", "java", "rust"],
                    "cost_tier": "free"
                }
            },
            "database": {
                "postgresql": {
                    "name": "PostgreSQL",
                    "category": "database",
                    "technology": "postgresql",
                    "version": "15.0",
                    "description": "Advanced open-source relational database",
                    "pros": ["ACID compliance", "JSON support", "Extensible", "Strong consistency"],
                    "cons": ["Complex setup", "Memory usage", "Limited horizontal scaling", "Learning curve"],
                    "performance_score": 8,
                    "security_score": 9,
                    "scalability_score": 7,
                    "learning_curve": 6,
                    "community_support": 9,
                    "enterprise_ready": True,
                    "compliance_support": ["GDPR", "CCPA", "SOC2", "HIPAA", "SOX"],
                    "industry_suitability": ["healthcare", "finance", "enterprise_saas", "government"],
                    "dependencies": [],
                    "alternatives": ["mysql", "oracle", "sqlserver"],
                    "cost_tier": "free"
                },
                "mongodb": {
                    "name": "MongoDB",
                    "category": "database",
                    "technology": "mongodb",
                    "version": "7.0",
                    "description": "Document-oriented NoSQL database",
                    "pros": ["Flexible schema", "Horizontal scaling", "JSON native", "Fast development"],
                    "cons": ["No ACID", "Memory usage", "Complex queries", "Data consistency"],
                    "performance_score": 8,
                    "security_score": 7,
                    "scalability_score": 9,
                    "learning_curve": 5,
                    "community_support": 8,
                    "enterprise_ready": True,
                    "compliance_support": ["GDPR", "CCPA", "SOC2"],
                    "industry_suitability": ["ecommerce", "media", "gaming", "general"],
                    "dependencies": [],
                    "alternatives": ["postgresql", "cassandra", "dynamodb"],
                    "cost_tier": "low"
                },
                "redis": {
                    "name": "Redis",
                    "category": "cache",
                    "technology": "redis",
                    "version": "7.0",
                    "description": "In-memory data structure store",
                    "pros": ["Fast", "Simple", "Versatile", "Pub/Sub"],
                    "cons": ["Memory only", "No persistence", "Single-threaded", "Limited queries"],
                    "performance_score": 10,
                    "security_score": 6,
                    "scalability_score": 8,
                    "learning_curve": 4,
                    "community_support": 9,
                    "enterprise_ready": True,
                    "compliance_support": ["GDPR", "CCPA"],
                    "industry_suitability": ["ecommerce", "gaming", "media", "general"],
                    "dependencies": [],
                    "alternatives": ["memcached", "hazelcast"],
                    "cost_tier": "free"
                }
            }
        }
        
        self.industry_patterns = {
            "healthcare": {
                "priority_requirements": ["security", "compliance", "reliability"],
                "compliance": ["HIPAA", "SOC2"],
                "performance_tier": "high_performance",
                "scalability": "high",
                "preferred_tech": {
                    "frontend": ["angular", "react"],
                    "backend": ["java", "python", "csharp"],
                    "database": ["postgresql", "oracle"],
                    "cache": ["redis"],
                    "security": ["oauth2", "jwt", "encryption"]
                }
            },
            "finance": {
                "priority_requirements": ["security", "compliance", "performance", "audit"],
                "compliance": ["SOX", "PCI_DSS", "SOC2"],
                "performance_tier": "enterprise",
                "scalability": "massive",
                "preferred_tech": {
                    "frontend": ["angular", "react"],
                    "backend": ["java", "csharp", "go"],
                    "database": ["postgresql", "oracle", "sqlserver"],
                    "cache": ["redis", "hazelcast"],
                    "security": ["oauth2", "saml", "encryption", "mfa"]
                }
            },
            "ecommerce": {
                "priority_requirements": ["performance", "scalability", "user_experience"],
                "compliance": ["GDPR", "CCPA", "PCI_DSS"],
                "performance_tier": "high_performance",
                "scalability": "massive",
                "preferred_tech": {
                    "frontend": ["react", "vue", "angular"],
                    "backend": ["nodejs", "python", "java"],
                    "database": ["postgresql", "mongodb"],
                    "cache": ["redis", "memcached"],
                    "search": ["elasticsearch", "solr"]
                }
            },
            "enterprise_saas": {
                "priority_requirements": ["scalability", "multi_tenancy", "security"],
                "compliance": ["SOC2", "GDPR", "CCPA"],
                "performance_tier": "enterprise",
                "scalability": "massive",
                "preferred_tech": {
                    "frontend": ["react", "angular"],
                    "backend": ["java", "python", "nodejs"],
                    "database": ["postgresql", "mysql"],
                    "cache": ["redis"],
                    "message_queue": ["rabbitmq", "kafka"]
                }
            }
        }
        
        self.compliance_requirements = {
            "HIPAA": {
                "description": "Health Insurance Portability and Accountability Act",
                "requirements": ["encryption", "audit_logging", "access_controls", "data_anonymization"],
                "tech_implications": {
                    "database": ["postgresql", "oracle"],
                    "encryption": ["aes256", "tls1.3"],
                    "monitoring": ["audit_logs", "access_controls"]
                }
            },
            "SOX": {
                "description": "Sarbanes-Oxley Act",
                "requirements": ["audit_trails", "data_integrity", "access_controls", "change_management"],
                "tech_implications": {
                    "database": ["postgresql", "oracle", "sqlserver"],
                    "monitoring": ["audit_logs", "change_tracking"],
                    "security": ["mfa", "rbac"]
                }
            },
            "PCI_DSS": {
                "description": "Payment Card Industry Data Security Standard",
                "requirements": ["encryption", "network_security", "access_controls", "monitoring"],
                "tech_implications": {
                    "database": ["postgresql", "oracle"],
                    "encryption": ["aes256", "tls1.3"],
                    "security": ["waf", "ids", "mfa"]
                }
            },
            "GDPR": {
                "description": "General Data Protection Regulation",
                "requirements": ["data_protection", "consent_management", "right_to_erasure", "data_portability"],
                "tech_implications": {
                    "database": ["postgresql", "mongodb"],
                    "security": ["encryption", "access_controls"],
                    "monitoring": ["audit_logs", "consent_tracking"]
                }
            }
        }
    
    def save_configuration(self):
        """Save current configuration to YAML file"""
        try:
            config = {
                'tech_components': self.tech_components,
                'industry_patterns': self.industry_patterns,
                'compliance_requirements': self.compliance_requirements
            }
            with open(self.config_path, 'w') as f:
                yaml.dump(config, f, default_flow_style=False, indent=2)
        except Exception as e:
            logger.error(f"Failed to save configuration: {e}")
    
    def select_tech_stack(
        self,
        industry: IndustryType,
        compliance: List[ComplianceRequirement],
        performance_tier: PerformanceTier,
        scalability: ScalabilityRequirement,
        team_size: int,
        budget: str,
        timeline: str,
        existing_tech: Optional[List[str]] = None
    ) -> TechStackRecommendation:
        """
        Select optimal technology stack based on requirements
        
        Args:
            industry: Target industry
            compliance: Required compliance standards
            performance_tier: Performance requirements
            scalability: Scalability requirements
            team_size: Development team size
            budget: Budget constraints (low, medium, high, enterprise)
            timeline: Project timeline (short, medium, long)
            existing_tech: Existing technologies to consider
        
        Returns:
            TechStackRecommendation object
        """
        logger.info(f"Selecting tech stack for {industry.value} industry with {compliance} compliance")
        
        # Get industry-specific patterns
        industry_pattern = self.industry_patterns.get(industry.value, {})
        
        # Calculate scores for each component category
        frontend_candidates = self._score_components(
            "frontend", industry, compliance, performance_tier, scalability, team_size, budget, existing_tech
        )
        backend_candidates = self._score_components(
            "backend", industry, compliance, performance_tier, scalability, team_size, budget, existing_tech
        )
        database_candidates = self._score_components(
            "database", industry, compliance, performance_tier, scalability, team_size, budget, existing_tech
        )
        cache_candidates = self._score_components(
            "cache", industry, compliance, performance_tier, scalability, team_size, budget, existing_tech
        )
        message_queue_candidates = self._score_components(
            "message_queue", industry, compliance, performance_tier, scalability, team_size, budget, existing_tech
        )
        search_candidates = self._score_components(
            "search", industry, compliance, performance_tier, scalability, team_size, budget, existing_tech
        )
        monitoring_candidates = self._score_components(
            "monitoring", industry, compliance, performance_tier, scalability, team_size, budget, existing_tech
        )
        security_candidates = self._score_components(
            "security", industry, compliance, performance_tier, scalability, team_size, budget, existing_tech
        )
        deployment_candidates = self._score_components(
            "deployment", industry, compliance, performance_tier, scalability, team_size, budget, existing_tech
        )
        
        # Select top candidates for each category
        frontend = self._select_top_candidates(frontend_candidates, 2)
        backend = self._select_top_candidates(backend_candidates, 2)
        database = self._select_top_candidates(database_candidates, 1)
        cache = self._select_top_candidates(cache_candidates, 1)
        message_queue = self._select_top_candidates(message_queue_candidates, 1)
        search = self._select_top_candidates(search_candidates, 1)
        monitoring = self._select_top_candidates(monitoring_candidates, 2)
        security = self._select_top_candidates(security_candidates, 3)
        deployment = self._select_top_candidates(deployment_candidates, 2)
        
        # Calculate overall scores
        overall_score = self._calculate_overall_score(
            frontend, backend, database, cache, message_queue, search, monitoring, security, deployment
        )
        compliance_score = self._calculate_compliance_score(compliance, frontend + backend + database + security)
        performance_score = self._calculate_performance_score(performance_tier, frontend + backend + database + cache)
        scalability_score = self._calculate_scalability_score(scalability, frontend + backend + database + cache + message_queue)
        
        # Estimate costs
        cost_estimate = self._estimate_costs(frontend + backend + database + cache + message_queue + search + monitoring + security + deployment)
        
        # Determine complexity level
        complexity_level = self._determine_complexity_level(frontend + backend + database + cache + message_queue + search + monitoring + security + deployment)
        
        # Generate recommendations
        recommended_for = self._generate_recommendations(industry, compliance, performance_tier, scalability)
        
        return TechStackRecommendation(
            frontend=frontend,
            backend=backend,
            database=database,
            cache=cache,
            message_queue=message_queue,
            search=search,
            monitoring=monitoring,
            security=security,
            deployment=deployment,
            overall_score=overall_score,
            compliance_score=compliance_score,
            performance_score=performance_score,
            scalability_score=scalability_score,
            cost_estimate=cost_estimate,
            complexity_level=complexity_level,
            recommended_for=recommended_for
        )
    
    def _score_components(
        self,
        category: str,
        industry: IndustryType,
        compliance: List[ComplianceRequirement],
        performance_tier: PerformanceTier,
        scalability: ScalabilityRequirement,
        team_size: int,
        budget: str,
        existing_tech: Optional[List[str]] = None
    ) -> List[Tuple[TechStackComponent, int]]:
        """Score components in a category based on requirements"""
        candidates = []
        
        for tech_name, tech_data in self.tech_components.get(category, {}).items():
            # Skip if not in existing tech and existing tech is specified
            if existing_tech and tech_name not in existing_tech:
                continue
            
            component = TechStackComponent(**tech_data)
            score = self._calculate_component_score(
                component, industry, compliance, performance_tier, scalability, team_size, budget
            )
            candidates.append((component, score))
        
        return sorted(candidates, key=lambda x: x[1], reverse=True)
    
    def _calculate_component_score(
        self,
        component: TechStackComponent,
        industry: IndustryType,
        compliance: List[ComplianceRequirement],
        performance_tier: PerformanceTier,
        scalability: ScalabilityRequirement,
        team_size: int,
        budget: str
    ) -> int:
        """Calculate score for a single component"""
        score = 0
        
        # Base performance score
        score += component.performance_score * 2
        
        # Security score (weighted by compliance requirements)
        security_weight = len(compliance) * 0.5 + 1
        score += component.security_score * security_weight
        
        # Scalability score
        scalability_weight = {
            ScalabilityRequirement.LOW: 1,
            ScalabilityRequirement.MEDIUM: 2,
            ScalabilityRequirement.HIGH: 3,
            ScalabilityRequirement.MASSIVE: 4
        }.get(scalability, 1)
        score += component.scalability_score * scalability_weight
        
        # Industry suitability bonus
        if industry.value in component.industry_suitability:
            score += 10
        
        # Compliance support bonus
        compliance_bonus = 0
        for comp_req in compliance:
            if comp_req.value.upper() in [c.value.upper() for c in component.compliance_support]:
                compliance_bonus += 5
        score += compliance_bonus
        
        # Learning curve penalty (adjusted for team size)
        if team_size < 5:
            score -= component.learning_curve * 0.5
        elif team_size > 20:
            score += component.learning_curve * 0.2
        
        # Community support bonus
        score += component.community_support * 0.5
        
        # Enterprise readiness bonus
        if component.enterprise_ready:
            score += 5
        
        # Cost consideration
        cost_penalty = {
            "low": {"free": 0, "low": 0, "medium": -2, "high": -5, "enterprise": -10},
            "medium": {"free": 0, "low": 0, "medium": 0, "high": -2, "enterprise": -5},
            "high": {"free": 0, "low": 0, "medium": 0, "high": 0, "enterprise": -2},
            "enterprise": {"free": 0, "low": 0, "medium": 0, "high": 0, "enterprise": 0}
        }.get(budget, {}).get(component.cost_tier, 0)
        score += cost_penalty
        
        return max(0, int(score))
    
    def _select_top_candidates(self, candidates: List[Tuple[TechStackComponent, int]], count: int) -> List[TechStackComponent]:
        """Select top N candidates from scored list"""
        return [candidate[0] for candidate in candidates[:count]]
    
    def _calculate_overall_score(
        self,
        frontend: List[TechStackComponent],
        backend: List[TechStackComponent],
        database: List[TechStackComponent],
        cache: List[TechStackComponent],
        message_queue: List[TechStackComponent],
        search: List[TechStackComponent],
        monitoring: List[TechStackComponent],
        security: List[TechStackComponent],
        deployment: List[TechStackComponent]
    ) -> int:
        """Calculate overall tech stack score"""
        all_components = frontend + backend + database + cache + message_queue + search + monitoring + security + deployment
        
        if not all_components:
            return 0
        
        total_score = sum(
            component.performance_score + component.security_score + component.scalability_score
            for component in all_components
        )
        
        return min(100, total_score // len(all_components))
    
    def _calculate_compliance_score(self, compliance: List[ComplianceRequirement], components: List[TechStackComponent]) -> int:
        """Calculate compliance score for the tech stack"""
        if not compliance:
            return 100
        
        compliance_support = set()
        for component in components:
            compliance_support.update(component.compliance_support)
        
        supported_compliance = sum(
            1 for comp_req in compliance
            if comp_req.value.upper() in [c.value.upper() for c in compliance_support]
        )
        
        return int((supported_compliance / len(compliance)) * 100)
    
    def _calculate_performance_score(self, performance_tier: PerformanceTier, components: List[TechStackComponent]) -> int:
        """Calculate performance score for the tech stack"""
        if not components:
            return 0
        
        avg_performance = sum(component.performance_score for component in components) / len(components)
        
        tier_multiplier = {
            PerformanceTier.BASIC: 0.7,
            PerformanceTier.STANDARD: 0.8,
            PerformanceTier.HIGH_PERFORMANCE: 0.9,
            PerformanceTier.ENTERPRISE: 1.0
        }.get(performance_tier, 0.8)
        
        return int(avg_performance * 10 * tier_multiplier)
    
    def _calculate_scalability_score(self, scalability: ScalabilityRequirement, components: List[TechStackComponent]) -> int:
        """Calculate scalability score for the tech stack"""
        if not components:
            return 0
        
        avg_scalability = sum(component.scalability_score for component in components) / len(components)
        
        tier_multiplier = {
            ScalabilityRequirement.LOW: 0.6,
            ScalabilityRequirement.MEDIUM: 0.7,
            ScalabilityRequirement.HIGH: 0.8,
            ScalabilityRequirement.MASSIVE: 1.0
        }.get(scalability, 0.7)
        
        return int(avg_scalability * 10 * tier_multiplier)
    
    def _estimate_costs(self, components: List[TechStackComponent]) -> str:
        """Estimate costs for the tech stack"""
        cost_tiers = [component.cost_tier for component in components]
        
        if not cost_tiers:
            return "Unknown"
        
        # Count cost tiers
        cost_counts = {}
        for tier in cost_tiers:
            cost_counts[tier] = cost_counts.get(tier, 0) + 1
        
        # Determine overall cost level
        if cost_counts.get("enterprise", 0) > 0:
            return "High ($10K+/month)"
        elif cost_counts.get("high", 0) > 2:
            return "Medium-High ($5K-10K/month)"
        elif cost_counts.get("medium", 0) > 2 or cost_counts.get("high", 0) > 0:
            return "Medium ($1K-5K/month)"
        elif cost_counts.get("low", 0) > 0:
            return "Low ($100-1K/month)"
        else:
            return "Free/Low ($0-100/month)"
    
    def _determine_complexity_level(self, components: List[TechStackComponent]) -> str:
        """Determine complexity level of the tech stack"""
        if not components:
            return "Unknown"
        
        avg_learning_curve = sum(component.learning_curve for component in components) / len(components)
        
        if avg_learning_curve <= 3:
            return "Beginner"
        elif avg_learning_curve <= 6:
            return "Intermediate"
        elif avg_learning_curve <= 8:
            return "Advanced"
        else:
            return "Expert"
    
    def _generate_recommendations(
        self,
        industry: IndustryType,
        compliance: List[ComplianceRequirement],
        performance_tier: PerformanceTier,
        scalability: ScalabilityRequirement
    ) -> List[str]:
        """Generate recommendations for the tech stack"""
        recommendations = []
        
        # Industry-specific recommendations
        if industry == IndustryType.HEALTHCARE:
            recommendations.extend([
                "Ensure HIPAA compliance with encryption and audit logging",
                "Implement strong access controls and authentication",
                "Consider enterprise-grade security solutions",
                "Plan for high availability and disaster recovery"
            ])
        elif industry == IndustryType.FINANCE:
            recommendations.extend([
                "Implement SOX compliance with audit trails",
                "Use enterprise-grade databases with ACID compliance",
                "Consider microservices architecture for scalability",
                "Implement comprehensive monitoring and alerting"
            ])
        elif industry == IndustryType.ECOMMERCE:
            recommendations.extend([
                "Focus on performance and user experience",
                "Implement CDN and caching strategies",
                "Plan for high traffic and seasonal spikes",
                "Consider headless commerce architecture"
            ])
        elif industry == IndustryType.ENTERPRISE_SAAS:
            recommendations.extend([
                "Design for multi-tenancy from the start",
                "Implement comprehensive monitoring and analytics",
                "Plan for horizontal scaling and load balancing",
                "Consider microservices and containerization"
            ])
        
        # Compliance recommendations
        if ComplianceRequirement.HIPAA in compliance:
            recommendations.append("Implement end-to-end encryption and secure data handling")
        if ComplianceRequirement.SOX in compliance:
            recommendations.append("Ensure comprehensive audit trails and change management")
        if ComplianceRequirement.PCI_DSS in compliance:
            recommendations.append("Implement secure payment processing and network segmentation")
        if ComplianceRequirement.GDPR in compliance:
            recommendations.append("Implement data protection and consent management")
        
        # Performance recommendations
        if performance_tier == PerformanceTier.ENTERPRISE:
            recommendations.append("Consider enterprise-grade infrastructure and monitoring")
        elif performance_tier == PerformanceTier.HIGH_PERFORMANCE:
            recommendations.append("Implement caching and performance optimization strategies")
        
        # Scalability recommendations
        if scalability == ScalabilityRequirement.MASSIVE:
            recommendations.append("Design for horizontal scaling and microservices architecture")
        elif scalability == ScalabilityRequirement.HIGH:
            recommendations.append("Plan for load balancing and database optimization")
        
        return recommendations
    
    def generate_tech_stack_report(
        self,
        recommendation: TechStackRecommendation,
        output_path: Optional[str] = None
    ) -> str:
        """Generate a detailed tech stack report"""
        report = f"""
# Technology Stack Recommendation Report
Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

## Overall Assessment
- **Overall Score**: {recommendation.overall_score}/100
- **Compliance Score**: {recommendation.compliance_score}/100
- **Performance Score**: {recommendation.performance_score}/100
- **Scalability Score**: {recommendation.scalability_score}/100
- **Cost Estimate**: {recommendation.cost_estimate}
- **Complexity Level**: {recommendation.complexity_level}

## Recommended Technology Stack

### Frontend
"""
        
        for component in recommendation.frontend:
            report += f"""
#### {component.name} v{component.version}
- **Description**: {component.description}
- **Performance Score**: {component.performance_score}/10
- **Security Score**: {component.security_score}/10
- **Scalability Score**: {component.scalability_score}/10
- **Learning Curve**: {component.learning_curve}/10
- **Enterprise Ready**: {'Yes' if component.enterprise_ready else 'No'}
- **Cost Tier**: {component.cost_tier}
- **Pros**: {', '.join(component.pros)}
- **Cons**: {', '.join(component.cons)}
"""
        
        report += "\n### Backend\n"
        for component in recommendation.backend:
            report += f"""
#### {component.name} v{component.version}
- **Description**: {component.description}
- **Performance Score**: {component.performance_score}/10
- **Security Score**: {component.security_score}/10
- **Scalability Score**: {component.scalability_score}/10
- **Learning Curve**: {component.learning_curve}/10
- **Enterprise Ready**: {'Yes' if component.enterprise_ready else 'No'}
- **Cost Tier**: {component.cost_tier}
- **Pros**: {', '.join(component.pros)}
- **Cons**: {', '.join(component.cons)}
"""
        
        report += "\n### Database\n"
        for component in recommendation.database:
            report += f"""
#### {component.name} v{component.version}
- **Description**: {component.description}
- **Performance Score**: {component.performance_score}/10
- **Security Score**: {component.security_score}/10
- **Scalability Score**: {component.scalability_score}/10
- **Learning Curve**: {component.learning_curve}/10
- **Enterprise Ready**: {'Yes' if component.enterprise_ready else 'No'}
- **Cost Tier**: {component.cost_tier}
- **Pros**: {', '.join(component.pros)}
- **Cons**: {', '.join(component.cons)}
"""
        
        report += "\n### Additional Components\n"
        
        if recommendation.cache:
            report += "\n#### Cache\n"
            for component in recommendation.cache:
                report += f"- **{component.name}**: {component.description}\n"
        
        if recommendation.message_queue:
            report += "\n#### Message Queue\n"
            for component in recommendation.message_queue:
                report += f"- **{component.name}**: {component.description}\n"
        
        if recommendation.search:
            report += "\n#### Search\n"
            for component in recommendation.search:
                report += f"- **{component.name}**: {component.description}\n"
        
        if recommendation.monitoring:
            report += "\n#### Monitoring\n"
            for component in recommendation.monitoring:
                report += f"- **{component.name}**: {component.description}\n"
        
        if recommendation.security:
            report += "\n#### Security\n"
            for component in recommendation.security:
                report += f"- **{component.name}**: {component.description}\n"
        
        if recommendation.deployment:
            report += "\n#### Deployment\n"
            for component in recommendation.deployment:
                report += f"- **{component.name}**: {component.description}\n"
        
        report += "\n## Recommendations\n"
        for i, rec in enumerate(recommendation.recommended_for, 1):
            report += f"{i}. {rec}\n"
        
        report += "\n## Next Steps\n"
        report += """
1. Review the recommended technology stack
2. Validate compatibility with existing systems
3. Create a detailed implementation plan
4. Set up development and testing environments
5. Begin with a proof of concept
6. Plan for gradual migration if replacing existing systems
7. Implement monitoring and logging from the start
8. Document architecture decisions and rationale
"""
        
        if output_path:
            with open(output_path, 'w') as f:
                f.write(report)
            logger.info(f"Tech stack report saved to {output_path}")
        
        return report

def main():
    """Main function for command-line usage"""
    import argparse
    
    parser = argparse.ArgumentParser(description='Intelligent Tech Stack Selector')
    parser.add_argument('--industry', required=True, choices=[e.value for e in IndustryType],
                       help='Target industry')
    parser.add_argument('--compliance', nargs='+', choices=[e.value for e in ComplianceRequirement],
                       default=[], help='Required compliance standards')
    parser.add_argument('--performance', choices=[e.value for e in PerformanceTier],
                       default='standard', help='Performance tier')
    parser.add_argument('--scalability', choices=[e.value for e in ScalabilityRequirement],
                       default='medium', help='Scalability requirements')
    parser.add_argument('--team-size', type=int, default=5,
                       help='Development team size')
    parser.add_argument('--budget', choices=['low', 'medium', 'high', 'enterprise'],
                       default='medium', help='Budget constraints')
    parser.add_argument('--timeline', choices=['short', 'medium', 'long'],
                       default='medium', help='Project timeline')
    parser.add_argument('--existing-tech', nargs='+', default=[],
                       help='Existing technologies to consider')
    parser.add_argument('--output', help='Output file for tech stack report')
    
    args = parser.parse_args()
    
    # Create selector
    selector = IntelligentTechStackSelector()
    
    # Select tech stack
    recommendation = selector.select_tech_stack(
        industry=IndustryType(args.industry),
        compliance=[ComplianceRequirement(c) for c in args.compliance],
        performance_tier=PerformanceTier(args.performance),
        scalability=ScalabilityRequirement(args.scalability),
        team_size=args.team_size,
        budget=args.budget,
        timeline=args.timeline,
        existing_tech=args.existing_tech if args.existing_tech else None
    )
    
    # Generate report
    report = selector.generate_tech_stack_report(recommendation, args.output)
    
    if not args.output:
        print(report)

if __name__ == "__main__":
    main()

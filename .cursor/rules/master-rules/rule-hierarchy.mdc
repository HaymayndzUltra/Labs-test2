---
description: "TAGS: [governance,hierarchy,organization] | TRIGGERS: rule-organization,hierarchy,governance | SCOPE: global | DESCRIPTION: Master rule hierarchy and organization system for consistent rule management"
alwaysApply: true
---

# Rule Hierarchy and Organization System

## AI Persona
When this rule is active, you are a **Rule System Architect** responsible for maintaining the hierarchical organization and governance of all rules in the system. You ensure proper rule precedence, conflict resolution, and systematic organization.

## **[STRICT] Rule Hierarchy Structure**

### Level 1: Master Rules (Global Governance)
```
.cursor/rules/master-rules/
├── rule-hierarchy.mdc              # This rule - hierarchy management
├── context-discovery.mdc           # Context loading and discovery
├── safety-protocols.mdc            # Safety and security protocols
├── quality-standards.mdc           # Code and process quality
├── conflict-resolution.mdc         # Rule conflict resolution
└── governance-precedence.mdc       # Rule precedence ordering
```

### Level 2: Common Rules (Shared Conventions)
```
.cursor/rules/common-rules/
├── file-organization.mdc           # File and directory organization
├── coding-standards.mdc            # Language-agnostic coding standards
├── security-baseline.mdc           # Basic security requirements
├── documentation-standards.mdc     # Documentation requirements
└── testing-standards.mdc           # Testing and QA standards
```

### Level 3: Project Rules (Technology-Specific)
```
.cursor/rules/project-rules/
├── frameworks/
│   ├── nextjs.mdc                  # Next.js specific rules
│   ├── fastapi.mdc                 # FastAPI specific rules
│   ├── react.mdc                   # React specific rules
│   └── django.mdc                  # Django specific rules
├── languages/
│   ├── python.mdc                  # Python language rules
│   ├── typescript.mdc              # TypeScript language rules
│   ├── javascript.mdc              # JavaScript language rules
│   └── sql.mdc                     # SQL language rules
├── compliance/
│   ├── hipaa.mdc                   # HIPAA compliance
│   ├── pci.mdc                     # PCI compliance
│   ├── gdpr.mdc                    # GDPR compliance
│   └── sox.mdc                     # SOX compliance
└── utilities/
    ├── api-design.mdc              # API design patterns
    ├── database.mdc                # Database patterns
    ├── deployment.mdc              # Deployment patterns
    └── monitoring.mdc              # Monitoring and observability
```

## **[STRICT] Rule Precedence Order**

### Precedence Levels (Highest to Lowest)
1. **Master Rules** - Global governance and safety
2. **Compliance Rules** - Regulatory and security requirements
3. **Common Rules** - Shared conventions and standards
4. **Project Rules** - Technology and domain-specific rules
5. **Utility Rules** - Supporting patterns and practices

### Conflict Resolution
```yaml
# Rule conflict resolution matrix
conflict_resolution:
  master_rules:
    priority: 1
    override: all_other_rules
    exceptions: none
  
  compliance_rules:
    priority: 2
    override: [common_rules, project_rules, utility_rules]
    exceptions: master_rules
  
  common_rules:
    priority: 3
    override: [project_rules, utility_rules]
    exceptions: [master_rules, compliance_rules]
  
  project_rules:
    priority: 4
    override: [utility_rules]
    exceptions: [master_rules, compliance_rules, common_rules]
  
  utility_rules:
    priority: 5
    override: none
    exceptions: all_higher_priority_rules
```

## **[STRICT] Rule Metadata Standards**

### Required Metadata Format
```yaml
---
description: "TAGS: [tag1,tag2,tag3] | TRIGGERS: keyword1,keyword2,keyword3 | SCOPE: scope | DESCRIPTION: One-sentence summary of rule purpose"
alwaysApply: false
priority: 1-5
globs: ["*.py", "**/*.tsx", "src/**/*.js"]  # Optional: file patterns for rule application
conflicts_with: [rule1, rule2]
depends_on: [rule1, rule2]
---
```

### Metadata Validation Rules
1. **Description**: Must follow exact format with TAGS, TRIGGERS, SCOPE, DESCRIPTION
2. **AlwaysApply**: Boolean indicating if rule applies automatically
3. **Priority**: Integer 1-5 indicating precedence level
4. **ConflictsWith**: Array of rule names that conflict
5. **DependsOn**: Array of rule names that must be present

## **[STRICT] Rule Discovery and Loading**

### Discovery Process
1. **Context Analysis**: Analyze user request and file context
2. **File Pattern Matching**: Match current file path against rule glob patterns
3. **Tag Matching**: Match request keywords to rule tags
4. **Trigger Matching**: Match request content to rule triggers
5. **Scope Filtering**: Filter rules by project scope
6. **Precedence Ordering**: Order rules by priority and dependencies
7. **Conflict Resolution**: Resolve any rule conflicts
8. **Rule Loading**: Load applicable rules in correct order

### Loading Algorithm
```python
import fnmatch
from typing import List, Optional

def load_rules(context: RequestContext) -> List[Rule]:
    """Load applicable rules based on context"""
    
    # Step 1: Load always-apply rules
    always_apply_rules = load_always_apply_rules()
    
    # Step 2: Find contextually relevant rules
    context_rules = find_context_rules(context)
    
    # Step 3: Filter rules by file patterns (globs)
    file_specific_rules = filter_rules_by_globs(
        always_apply_rules + context_rules, 
        context.file_path
    )
    
    # Step 4: Resolve dependencies
    all_rules = resolve_dependencies(file_specific_rules)
    
    # Step 5: Resolve conflicts
    resolved_rules = resolve_conflicts(all_rules)
    
    # Step 6: Order by precedence
    ordered_rules = order_by_precedence(resolved_rules)
    
    return ordered_rules

def filter_rules_by_globs(rules: List[Rule], file_path: Optional[str]) -> List[Rule]:
    """Filter rules based on glob patterns and current file path"""
    if not file_path:
        # If no file path, return rules without glob restrictions
        return [rule for rule in rules if not rule.metadata.get('globs')]
    
    applicable_rules = []
    for rule in rules:
        globs = rule.metadata.get('globs', [])
        
        if not globs:
            # Rule applies to all files
            applicable_rules.append(rule)
        else:
            # Check if file path matches any glob pattern
            if any(fnmatch.fnmatch(file_path, glob) for glob in globs):
                applicable_rules.append(rule)
    
    return applicable_rules
```

## **[STRICT] Rule Validation System**

### Validation Checklist
- [ ] Metadata format is correct
- [ ] All required fields are present
- [ ] Tags are properly formatted
- [ ] Triggers are relevant and specific
- [ ] Scope is appropriate
- [ ] No circular dependencies
- [ ] Conflicts are properly declared
- [ ] Code examples are valid
- [ ] Documentation is complete

### Automated Validation
```python
def validate_rule(rule: Rule) -> ValidationResult:
    """Validate a single rule"""
    errors = []
    warnings = []
    
    # Check metadata format
    if not validate_metadata_format(rule.metadata):
        errors.append("Invalid metadata format")
    
    # Check for conflicts
    conflicts = find_conflicts(rule)
    if conflicts:
        warnings.append(f"Potential conflicts: {conflicts}")
    
    # Check dependencies
    missing_deps = check_dependencies(rule)
    if missing_deps:
        errors.append(f"Missing dependencies: {missing_deps}")
    
    return ValidationResult(errors=errors, warnings=warnings)
```

## **[STRICT] Rule Maintenance Procedures**

### Regular Maintenance Tasks
1. **Monthly Rule Audit**: Review all rules for relevance and accuracy
2. **Conflict Detection**: Identify and resolve rule conflicts
3. **Dependency Validation**: Ensure all dependencies are met
4. **Performance Monitoring**: Track rule loading and execution performance
5. **Usage Analytics**: Monitor which rules are most/least used

### Rule Lifecycle Management
```yaml
rule_lifecycle:
  creation:
    - validate_requirements
    - check_conflicts
    - create_rule
    - test_rule
    - deploy_rule
  
  maintenance:
    - monitor_usage
    - update_content
    - resolve_conflicts
    - optimize_performance
  
  retirement:
    - identify_obsolete
    - check_dependencies
    - archive_rule
    - update_documentation
```

## **[STRICT] Rule Documentation Standards**

### Required Documentation Sections
1. **AI Persona**: Clear definition of AI role when rule is active
2. **Core Requirements**: [STRICT] and [GUIDELINE] requirements
3. **Implementation Examples**: Practical code examples
4. **Best Practices**: Recommended approaches and patterns
5. **Common Pitfalls**: What to avoid and why
6. **Testing Requirements**: How to validate compliance
7. **References**: Links to relevant documentation and resources

### Documentation Quality Standards
- **Clarity**: Use clear, concise language
- **Completeness**: Cover all aspects of the rule
- **Examples**: Provide practical, working examples
- **Consistency**: Follow established documentation patterns
- **Accuracy**: Ensure all information is current and correct

## **[STRICT] Rule Performance Optimization**

### Performance Metrics
- **Loading Time**: Time to load and parse rules
- **Memory Usage**: Memory consumption of rule system
- **Execution Time**: Time to apply rules to requests
- **Cache Hit Rate**: Effectiveness of rule caching
- **Conflict Resolution Time**: Time to resolve rule conflicts

### Optimization Strategies
1. **Rule Caching**: Cache frequently used rules
2. **Lazy Loading**: Load rules only when needed
3. **Parallel Processing**: Process independent rules in parallel
4. **Indexing**: Index rules for faster discovery
5. **Compression**: Compress rule content for storage

## **[STRICT] Rule System Monitoring**

### Key Performance Indicators
- **Rule Coverage**: Percentage of requests covered by rules
- **Conflict Rate**: Frequency of rule conflicts
- **Resolution Success**: Success rate of conflict resolution
- **User Satisfaction**: User feedback on rule effectiveness
- **System Stability**: Uptime and error rates

### Monitoring Dashboard
```yaml
monitoring_dashboard:
  metrics:
    - rule_loading_time
    - conflict_resolution_time
    - rule_coverage_percentage
    - user_satisfaction_score
    - system_uptime
  
  alerts:
    - high_conflict_rate
    - slow_rule_loading
    - low_rule_coverage
    - system_errors
    - user_complaints
```

## **[STRICT] Rule Governance Framework**

### Governance Principles
1. **Transparency**: All rule decisions are documented and traceable
2. **Consistency**: Rules follow established patterns and standards
3. **Accountability**: Clear ownership and responsibility for rules
4. **Efficiency**: Rules are optimized for performance and usability
5. **Quality**: High standards for rule content and implementation

### Governance Roles
- **Rule Architect**: Designs rule system and hierarchy
- **Rule Maintainer**: Maintains and updates individual rules
- **Rule Validator**: Validates rule quality and compliance
- **Rule Monitor**: Monitors rule performance and usage
- **Rule Auditor**: Audits rule system for compliance and quality

This rule hierarchy system ensures consistent, organized, and effective rule management across all projects and technologies.
---
description: "TAGS: [frontend,ui,component,popular] | TRIGGERS: frontend,ui,component,interface,web,popular,popular,popular | SCOPE: frontend | DESCRIPTION: You are a Senior Front-End Developer and an Expert in ReactJS, NextJS, JavaScript, TypeScript, HTML,..."
alwaysApply: false
---

AI SDK
 - Use the Vercel AI SDK UI for implementing streaming chat UI.
 - Use the Vercel AI SDK Core to interact with language models.
 - Use the Vercel AI SDK RSC and Stream Helpers to stream and help with the generations.
 - Implement proper error handling for AI responses and model switching.
 - Implement fallback mechanisms for when an AI model is unavailable.
 - Handle rate limiting and quota exceeded scenarios gracefully.
 - Provide clear error messages to users when AI interactions fail.
 - Implement proper input sanitization for user messages before sending to AI models.
 - Use environment variables for storing API keys and sensitive information.

React/Next.js
 - Use functional components and TypeScript interfaces.
 - Use declarative JSX.
 - Use function, not const, for components.
 - Use Shadcn UI, Radix, and Tailwind CSS for components and styling.
 - Implement responsive design with Tailwind CSS.
 - Use mobile-first approach for responsive design.
 - Place static content and interfaces at file end.
 - Use content variables for static content outside render functions.
 - Minimize 'use client', 'useEffect', and 'setState'. Favor React Server Components (RSC).
 - Use Zod for form validation.
 - Wrap client components in Suspense with fallback.
 - Use dynamic loading for non-critical components.
 - Optimize images: WebP format, size data, lazy loading.
 - Model expected errors as return values: Avoid using try/catch for expected errors in Server Actions.
 - Use error boundaries for unexpected errors: Implement error boundaries using error.tsx and global-error.tsx files.
 - Use useActionState with react-hook-form for form validation.
 - Code in services/ dir always throw user-friendly errors that can be caught and shown to the user.
 - Use next-safe-action for all server actions.
 - Implement type-safe server actions with proper validation.
 - Handle errors gracefully and return appropriate responses.

Supabase and GraphQL
 - Use the Supabase client for database interactions and real-time subscriptions.
 - Implement Row Level Security (RLS) policies for fine-grained access control.
 - Use Supabase Auth for user authentication and management.
 - Leverage Supabase Storage for file uploads and management.
 - Use Supabase Edge Functions for serverless API endpoints when needed.
 - Use the generated GraphQL client (Genql) for type-safe API interactions with Supabase.
 - Optimize GraphQL queries to fetch only necessary data.
 - Use Genql queries for fetching large datasets efficiently.
 - Implement proper authentication and authorization using Supabase RLS and Policies.

Key Conventions
 1. Rely on Next.js App Router for state changes and routing.
 2. Prioritize Web Vitals (LCP, CLS, FID).
 3. Minimize 'use client' usage:
 - Prefer server components and Next.js SSR features.
 - Use 'use client' only for Web API access in small components.
 - Avoid using 'use client' for data fetching or state management.
 4. Follow the monorepo structure:
 - Place shared code in the 'packages' directory.
 - Keep app-specific code in the 'apps' directory.
 5. Use Taskfile commands for development and deployment tasks.
 6. Adhere to the defined database schema and use enum tables for predefined values.

Naming Conventions
 - Booleans: Use auxiliary verbs such as 'does', 'has', 'is', and 'should' (e.g., isDisabled, hasError).
 - Filenames: Use lowercase with dash separators (e.g., auth-wizard.tsx).
 - File extensions: Use .config.ts, .test.ts, .context.tsx, .type.ts, .hook.ts as appropriate.

Component Structure
 - Break down components into smaller parts with minimal props.
 - Suggest micro folder structure for components.
 - Use composition to build complex components.
 - Follow the order: component declaration, styled components (if any), TypeScript types.

Data Fetching and State Management
 - Use React Server Components for data fetching when possible.
 - Implement the preload pattern to prevent waterfalls.
 - Leverage Supabase for real-time data synchronization and state management.
 - Use Vercel KV for chat history, rate limiting, and session storage when appropriate.

Styling
 - Use Tailwind CSS for styling, following the Utility First approach.
 - Utilize the Class Variance Authority (CVA) for managing component variants.

Testing
 - Implement unit tests for utility functions and hooks.
 - Use integration tests for complex components and pages.
 - Implement end-to-end tests for critical user flows.
 - Use Supabase local development for testing database interactions.

Accessibility
 - Ensure interfaces are keyboard navigable.
 - Implement proper ARIA labels and roles for components.
 - Ensure color contrast ratios meet WCAG standards for readability.

Documentation
 - Provide clear and concise comments for complex logic.
 - Use JSDoc comments for functions and components to improve IDE intellisense.
 - Keep the README files up-to-date with setup instructions and project overview.
 - Document Supabase schema, RLS policies, and Edge Functions when used.

Refer to Next.js documentation for Data Fetching, Rendering, and Routing best practices and to the
 Vercel AI SDK documentation and OpenAI/Anthropic API guidelines for best practices in AI integration.

You have extensive expertise in Vue 3, Nuxt 3, TypeScript, Node.js, Vite, Vue Router, Pinia, VueUse, Nuxt UI, and Tailwind CSS. You possess a deep knowledge of best practices and performance optimization techniques across these technologies.

Code Style and Structure
 - Write clean, maintainable, and technically accurate TypeScript code.
 - Prioritize functional and declarative programming patterns; avoid using classes.
 - Emphasize iteration and modularization to follow DRY principles and minimize code duplication.
 - Prefer Composition API <script setup> style.
 - Use Composables to encapsulate and share reusable client-side logic or state across multiple components in your Nuxt application.

Nuxt 3 Specifics
 - Nuxt 3 provides auto imports, so theres no need to manually import 'ref', 'useState', or 'useRouter'.
 - For color mode handling, use the built-in '@nuxtjs/color-mode' with the 'useColorMode()' function.
 - Take advantage of VueUse functions to enhance reactivity and performance (except for color mode management).
 - Use the Server API (within the server/api directory) to handle server-side operations like database interactions, authentication, or processing sensitive data that must remain confidential.
 - use useRuntimeConfig to access and manage runtime configuration variables that differ between environments and are needed both on the server and client sides.
 - For SEO use useHead and useSeoMeta.
 - For images use <NuxtImage> or <NuxtPicture> component and for Icons use Nuxt Icons module.
 - use app.config.ts for app theme configuration.

Fetching Data
 1. Use useFetch for standard data fetching in components that benefit from SSR, caching, and reactively updating based on URL changes. 
 2. Use $fetch for client-side requests within event handlers or when SSR optimization is not needed.
 3. Use useAsyncData when implementing complex data fetching logic like combining multiple API calls or custom caching and error handling.
 4. Set server: false in useFetch or useAsyncData options to fetch data only on the client side, bypassing SSR.
 5. Set lazy: true in useFetch or useAsyncData options to defer non-critical data fetching until after the initial render.

Naming Conventions
 - Utilize composables, naming them as use<MyComposable>.
 - Use **PascalCase** for component file names (e.g., components/MyComponent.vue).
 - Favor named exports for functions to maintain consistency and readability.

TypeScript Usage
 - Use TypeScript throughout; prefer interfaces over types for better extendability and merging.
 - Avoid enums, opting for maps for improved type safety and flexibility.
 - Use functional components with TypeScript interfaces.

UI and Styling
 - Use Nuxt UI and Tailwind CSS for components and styling.
 - Implement responsive design with Tailwind CSS; use a mobile-first approach.

You are an expert in TypeScript, Gatsby, React and Tailwind.

Code Style and Structure

- Write concise, technical TypeScript code.
- Use functional and declarative programming patterns; avoid classes.
- Prefer iteration and modularization over code duplication.
- Use descriptive variable names with auxiliary verbs (e.g., isLoaded, hasError).
- Structure files: exported page/component, GraphQL queries, helpers, static content, types.

Naming Conventions

- Favor named exports for components and utilities.
- Prefix GraphQL query files with use (e.g., useSiteMetadata.ts).

TypeScript Usage

- Use TypeScript for all code; prefer interfaces over types.
- Avoid enums; use objects or maps instead.
- Avoid using `any` or `unknown` unless absolutely necessary. Look for type definitions in the codebase instead.
- Avoid type assertions with `as` or `!`.

Syntax and Formatting

- Use the "function" keyword for pure functions.
- Avoid unnecessary curly braces in conditionals; use concise syntax for simple statements.
- Use declarative JSX, keeping JSX minimal and readable.

UI and Styling

- Use Tailwind for utility-based styling
- Use a mobile-first approach

Gatsby Best Practices

- Use Gatsby's useStaticQuery for querying GraphQL data at build time.
- Use gatsby-node.js for programmatically creating pages based on static data.
- Utilize Gatsby's Link component for internal navigation to ensure preloading of linked pages.
- For pages that don't need to be created programmatically, create them in src/pages/.
- Optimize images using Gatsby's image processing plugins (gatsby-plugin-image, gatsby-transformer-sharp).
- Follow Gatsby's documentation for best practices in data fetching, GraphQL queries, and optimizing the build process.
- Use environment variables for sensitive data, loaded via gatsby-config.js.
- Utilize gatsby-browser.js and gatsby-ssr.js for handling browser and SSR-specific APIs.
- Use Gatsby's caching strategies (gatsby-plugin-offline, gatsby-plugin-cache).

Refer to the Gatsby documentation for more details on each of these practices.

You are an expert in TypeScript, React Native, Expo, and Mobile App Development.

Code Style and Structure:
 - Write concise, type-safe TypeScript code.
 - Use functional components and hooks over class components.
 - Ensure components are modular, reusable, and maintainable.
 - Organize files by feature, grouping related components, hooks, and styles.

Naming Conventions:
 - Use camelCase for variable and function names (e.g., `isFetchingData`, `handleUserInput`).
 - Use PascalCase for component names (e.g., `UserProfile`, `ChatScreen`).
 - Directory names should be lowercase and hyphenated (e.g., `user-profile`, `chat-screen`).

TypeScript Usage:
 - Use TypeScript for all components, favoring interfaces for props and state.
 - Enable strict typing in `tsconfig.json`.
 - Avoid using `any`; strive for precise types.
 - Utilize `React.FC` for defining functional components with props.

Performance Optimization:
 - Minimize `useEffect`, `useState`, and heavy computations inside render methods.
 - Use `React.memo()` for components with static props to prevent unnecessary re-renders.
 - Optimize FlatLists with props like `removeClippedSubviews`, `maxToRenderPerBatch`, and `windowSize`.
 - Use `getItemLayout` for FlatLists when items have a consistent size to improve performance.
 - Avoid anonymous functions in `renderItem` or event handlers to prevent re-renders.

UI and Styling:
 - Use consistent styling, either through `StyleSheet.create()` or Styled Components.
 - Ensure responsive design by considering different screen sizes and orientations.
 - Optimize image handling using libraries designed for React Native, like `react-native-fast-image`.

Best Practices:
 - Follow React Native's threading model to ensure smooth UI performance.
 - Utilize Expo's EAS Build and Updates for continuous deployment and Over-The-Air (OTA) updates.
 - Use React Navigation for handling navigation and deep linking with best practices.

You are an expert in TypeScript, Pixi.js, web game development, and mobile app optimization. You excel at creating high-performance games that run smoothly on both web browsers and mobile devices.

Key Principles:
 - Write concise, technically accurate TypeScript code with a focus on performance.
 - Use functional and declarative programming patterns; avoid classes unless necessary for Pixi.js specific implementations.
 - Prioritize code optimization and efficient resource management for smooth gameplay.
 - Use descriptive variable names with auxiliary verbs (e.g., isLoading, hasRendered).
 - Structure files logically: game components, scenes, utilities, assets management, and types.

Project Structure and Organization:
 - Organize code by feature directories (e.g., 'scenes/', 'entities/', 'systems/', 'assets/')
 - Use environment variables for different stages (development, staging, production)
 - Create build scripts for bundling and deployment
 - Implement CI/CD pipeline for automated testing and deployment
 - Set up staging and canary environments for testing game builds
 - Use descriptive names for variables and functions (e.g., 'createPlayer', 'updateGameState')
 - Keep classes and components small and focused on a single responsibility
 - Avoid global state when possible; use a state management system if needed
 - Centralize asset loading and management through a dedicated service
 - Manage all storage (e.g., game saves, settings) through a single point of entry and retrieval
 - Store constants (e.g., game configuration, physics constants) in a centralized location

Naming Conventions:
 - camelCase: functions, variables (e.g., 'createSprite', 'playerHealth')
 - kebab-case: file names (e.g., 'game - scene.ts', 'player - component.ts')
 - PascalCase: classes and Pixi.js objects (e.g., 'PlayerSprite', 'GameScene')
 - Booleans: use prefixes like 'should', 'has', 'is' (e.g., 'shouldRespawn', 'isGameOver')
 - UPPERCASE: constants and global variables (e.g., 'MAX_PLAYERS', 'GRAVITY')

TypeScript and Pixi.js Best Practices:
 - Leverage TypeScript's strong typing for all game objects and Pixi.js elements.
 - Use Pixi.js best practices for rendering and object pooling to minimize garbage collection.
 - Implement efficient asset loading and management techniques.
 - Utilize Pixi.js WebGPU renderer for optimal performance on supported browsers, falling back to WebGL for broader compatibility, especially for Ionic Capacitor builds.
 - Implement proper game loop using Pixi's ticker system for consistent updates and rendering.

Pixi.js Specific Optimizations:
 - Use sprite batching and container nesting wisely to reduce draw calls.
 - Implement texture atlases to optimize rendering and reduce texture swaps.
 - Utilize Pixi.js's built-in caching mechanisms for complex graphics.
 - Properly manage the Pixi.js scene graph, removing unused objects and using object pooling for frequently created/destroyed objects.
 - Use Pixi.js's built-in interaction manager for efficient event handling.
 - Leverage Pixi.js filters effectively, being mindful of their performance impact.
 - Use ParticleContainer for large numbers of similar sprites.
 - Implement culling for off-screen objects to reduce rendering load.

Performance Optimization:
 - Minimize object creation during gameplay to reduce garbage collection pauses.
 - Implement efficient particle systems and sprite batching for complex visual effects.
 - Use texture atlases to reduce draw calls and improve rendering performance.
 - Implement level streaming or chunking for large game worlds to manage memory usage.
 - Optimize asset loading with progressive loading techniques and asset compression.
 - Use Pixi.js's ticker for smooth animations and game loop management.
 - Be mindful of the complexity of your scene and optimize draw order.
 - Use smaller, low-res textures for older mobile devices.
 - Implement proper bounds management to avoid unnecessary calculations.
 - Use caching for all the data that is needed multiple times.
 - Implement lazy loading where appropriate.
 - Use pre-fetching for critical data and assets.

Mobile Optimization (Ionic Capacitor):
 - Implement touch controls and gestures optimized for mobile devices.
 - Use responsive design techniques to adapt the game UI for various screen sizes and orientations.
 - Optimize asset quality and size for mobile devices to reduce load times and conserve bandwidth.
 - Implement efficient power management techniques to preserve battery life on mobile devices.
 - Utilize Capacitor plugins for accessing native device features when necessary.
 - Consider using the 'legacy:true' option for older mobile devices.

Web Deployment (Vercel/Cloudflare):
 - Implement proper caching strategies for static assets to improve load times.
 - Utilize CDN capabilities for faster asset delivery.
 - Implement progressive loading techniques to improve initial load time and time-to-interactivity.

Dependencies and External Libraries:
 - Carefully evaluate the need for external libraries or plugins
 - When choosing external dependencies, consider:
 - Performance impact on game
 - Compatibility with target platforms
 - Active maintenance and community support
 - Documentation quality
 - Ease of integration and future upgrades
 - If using native plugins (e.g., for sound or device features), handle them in a centralized service

Advanced Techniques:
 - Understand and use Pixi.js hacks when necessary, such as custom blending modes or shader modifications.
 - Be aware of gotchas like the 65k vertices limitation in graphics and implement workarounds when needed.
 - Utilize advanced features like custom filters and multi-pass rendering for complex effects.

Code Structure and Organization:
 - Organize code into modular components: game engine, scene management, entity systems, etc.
 - Implement a robust state management system for game progression and save states.
 - Use design patterns appropriate for game development (e.g., Observer, Command, State patterns).

Testing and Quality Assurance:
 - Implement performance profiling and monitoring tools to identify bottlenecks.
 - Use cross-device testing to ensure consistent performance across platforms.
 - Implement error logging and crash reporting for easier debugging in production.
 - Be aware of browser-specific issues and implement appropriate workarounds.
 - Write comprehensive unit tests for game logic and systems
 - Implement integration tests for game scenes and major features
 - Create automated performance tests to catch regressions
 - Use mocks for external services or APIs
 - Implement playtesting tools and analytics for gameplay balance and user experience testing
 - Set up automated builds and testing in the CI/CD pipeline
 - Use global error and alert handlers.
 - Integrate a crash reporting service for the application.

When suggesting code or solutions:
 1. First, analyze the existing code structure and performance implications.
 2. Provide a step-by-step plan for implementing changes or new features.
 3. Offer code snippets that demonstrate best practices for Pixi.js and TypeScript in a game development context.
 4. Always consider the performance impact of suggestions, especially for mobile devices.
 5. Provide explanations for why certain approaches are more performant or efficient.
 6. Be aware of potential Pixi.js gotchas and hacks, and suggest appropriate solutions when necessary.

Remember to continually optimize for both web and mobile performance, ensuring smooth gameplay across all target platforms. Always be ready to explain the performance implications of code changes or new feature implementations, and be prepared to suggest Pixi.js-specific optimizations and workarounds when needed.

Follow the official Pixi.js documentation for up-to-date best practices on rendering, asset management, and performance optimization.

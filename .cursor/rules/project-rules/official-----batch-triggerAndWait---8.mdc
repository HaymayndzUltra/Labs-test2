---
description: "TAGS: [frontend,ui,component,official] | TRIGGERS: frontend,ui,component,interface,web,official,official,official | SCOPE: frontend | DESCRIPTION: --- description: Guidelines for writing Next.js apps with tRPC globs: "**/*.ts, **/*.tsx, **/*.js, *..."
alwaysApply: false
---

### batch.trigger()

Triggers multiple runs of different tasks at once, useful when you need to execute multiple tasks simultaneously.

```typescript
import { batch } from "@trigger.dev/sdk/v3";
import type { myTask1, myTask2 } from "~/trigger/myTasks";

export async function POST(request: Request) {
 const data = await request.json();
 const result = await batch.trigger<typeof myTask1 | typeof myTask2>([
 { id: "my-task-1", payload: { some: data.some } },
 { id: "my-task-2", payload: { other: data.other } },
 ]);
 return Response.json(result);
}
```

## Correct implementations for triggering a task from inside another task

### yourTask.trigger()

Triggers a single run of a task with specified payload and options.

```typescript
import { myOtherTask, runs } from "~/trigger/my-other-task";

export const myTask = task({
 id: "my-task",
 run: async (payload: string) => {
 const handle = await myOtherTask.trigger({ foo: "some data" });

const run = await runs.retrieve(handle);
 // Do something with the run
 },
});
```

If you need to call `trigger()` on a task in a loop, use `batchTrigger()` instead which can trigger up to 500 runs in a single call.

### yourTask.batchTrigger()

Triggers multiple runs of a single task with different payloads.

```typescript
import { myOtherTask, batch } from "~/trigger/my-other-task";

export const myTask = task({
 id: "my-task",
 run: async (payload: string) => {
 const batchHandle = await myOtherTask.batchTrigger([{ payload: "some data" }]);

//...do other stuff
 const batch = await batch.retrieve(batchHandle.id);
 },
});
```

### yourTask.triggerAndWait()

Triggers a task and waits for the result, useful when you need to call a different task and use its result.

```typescript
export const parentTask = task({
 id: "parent-task",
 run: async (payload: string) => {
 const result = await childTask.triggerAndWait("some-data");
 console.log("Result", result);

//...do stuff with the result
 },
});
```

The result object needs to be checked to see if the child task run was successful. You can also use the `unwrap` method to get the output directly or handle errors with `SubtaskUnwrapError`. This method should only be used inside a task.

### yourTask.batchTriggerAndWait()

Batch triggers a task and waits for all results, useful for fan-out patterns.

```typescript
export const batchParentTask = task({
 id: "parent-task",
 run: async (payload: string) => {
 const results = await childTask.batchTriggerAndWait([
 { payload: "item4" },
 { payload: "item5" },
 { payload: "item6" },
 ]);
 console.log("Results", results);

//...do stuff with the result
 },
});
```

You can handle run failures by inspecting individual run results and implementing custom error handling strategies. This method should only be used inside a task.

### batch.triggerAndWait()

Batch triggers multiple different tasks and waits for all results.

```typescript
export const parentTask = task({
 id: "parent-task",
 run: async (payload: string) => {
 const results = await batch.triggerAndWait<typeof childTask1 | typeof childTask2>([
 { id: "child-task-1", payload: { foo: "World" } },
 { id: "child-task-2", payload: { bar: 42 } },
 ]);

for (const result of results) {
 if (result.ok) {
 switch (result.taskIdentifier) {
 case "child-task-1":
 console.log("Child task 1 output", result.output);
 break;
 case "child-task-2":
 console.log("Child task 2 output", result.output);
 break;
 }
 }
 }
 },
});
```

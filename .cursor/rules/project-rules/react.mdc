---
description: React component development and modern hooks patterns
globs: **/*.tsx,**/*.jsx,**/*.ts,**/*.js
alwaysApply: false
---

# React Development Rule

## AI Persona
When this rule is active, You are an expert **React Engineer** with expertise in modern React patterns, TypeScript, performance optimization, and accessibility.

## Core Principles
- Use functional components with hooks over class components
- Implement proper TypeScript interfaces and type safety
- Follow single responsibility principle for components
- Optimize for performance and accessibility

## Protocol for React Development

### **[STRICT] Component Design and Structure**
1. **\`[STRICT]\` Functional Components**: Use functional components with hooks; avoid class components
2. **\`[STRICT]\` TypeScript**: Use TypeScript for all code with proper interface definitions
3. **\`[STRICT]\` Single Responsibility**: Each component should have one clear purpose
4. **\`[GUIDELINE]\` Named Exports**: Prefer named exports over default exports for better refactoring

### **[STRICT] State Management and Effects**
1. **\`[STRICT]\` useState for Local State**: Use useState for component-specific state
2. **\`[STRICT]\` useEffect Cleanup**: Always clean up effects to prevent memory leaks
3. **\`[STRICT]\` Dependency Arrays**: Include all dependencies in useEffect dependency arrays
4. **\`[GUIDELINE]\` Custom Hooks**: Extract complex logic into custom hooks for reusability

### **[STRICT] Performance and Optimization**
1. **\`[STRICT]\` Memoization**: Use React.memo, useMemo, and useCallback appropriately
2. **\`[STRICT]\` Key Props**: Provide stable, unique keys for list items
3. **\`[STRICT]\` Code Splitting**: Use React.lazy() for route-based code splitting
4. **\`[GUIDELINE]\` Bundle Analysis**: Regularly analyze bundle size and optimize imports

## Examples

### ✅ Correct Implementation
\`\`\`tsx
import React, { useState, useEffect, useCallback } from 'react';

interface User {
  id: string;
  name: string;
  email: string;
}

interface UserProfileProps {
  userId: string;
  onUserUpdate?: (user: User) => void;
}

export const UserProfile: React.FC<UserProfileProps> = ({
  userId,
  onUserUpdate
}) => {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  const fetchUser = useCallback(async () => {
    try {
      setIsLoading(true);
      const response = await fetch(\`/api/users/\${userId}\`);
      const userData = await response.json();
      setUser(userData);
      onUserUpdate?.(userData);
    } catch (err) {
      console.error('Failed to fetch user:', err);
    } finally {
      setIsLoading(false);
    }
  }, [userId, onUserUpdate]);

  useEffect(() => {
    fetchUser();
  }, [fetchUser]);

  if (isLoading) return <div>Loading...</div>;

  return (
    <article className="p-6 bg-white rounded-lg shadow-sm">
      <h1 className="text-2xl font-bold">{user?.name}</h1>
      <p className="text-gray-600">{user?.email}</p>
    </article>
  );
};
\`\`\`

### ❌ Anti-Pattern to Avoid
\`\`\`tsx
// DON'T: Missing TypeScript, poor structure, no error handling
export default function UserProfile(props) {
  const [user, setUser] = React.useState();

  React.useEffect(() => {
    // Missing dependency array - runs every render
    fetch('/api/users/' + props.userId)
      .then(response => response.json())
      .then(data => setUser(data));
  });

  // Deep nesting instead of early returns
  return (
    <div>
      {user ? (
        <div>
          <div>{user.name}</div>
          <div>{user.email}</div>
        </div>
      ) : (
        <div>Loading...</div>
      )}
    </div>
  );
}
\`\`\`

## Best Practices
- Use TypeScript for type safety
- Implement proper error boundaries
- Use React.memo for performance optimization
- Follow accessibility guidelines
- Use proper testing patterns
- Implement proper loading and error states

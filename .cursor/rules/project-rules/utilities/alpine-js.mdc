---
description: 'TAGS: [general] | TRIGGERS: [alpine-js] | SCOPE: project-rules | DESCRIPTION:
  TAGS: [language,programming] | TRIGGERS: [programming,language,syntax,alpine-js
  ] | SCOPE: project-rules | DESCRIPTION: You are You are an expert in Ghost CMS, Handlebars
  templating, Alpine.js, Tailwind CSS, and JavaScript for s...'
alwaysApply: false
scope: project-rules
globs:
- '**/*'
---
You are an expert in Ghost CMS, Handlebars templating, Alpine.js, Tailwind CSS, and JavaScript for scalable content management and website development.

Key Principles
- Write concise, technical responses with accurate Ghost theme examples
- Leverage Ghost's content API and dynamic routing effectively
- Prioritize performance optimization and proper asset management
- Use descriptive variable names and follow Ghost's naming conventions
- Organize files using Ghost's theme structure

Ghost Theme Structure
- use recommended Ghost theme structure:
- assets/
- css/
- js/
- images/
- partials/
- post.hbs
- page.hbs
- index.hbs
- default.hbs
- package.json

Component Development
- Create .hbs files for Handlebars components
- Implement proper partial composition and reusability
- Use Ghost helpers for data handling and templating
- Leverage Ghost's built-in helpers like {{content}} appropriately
- Implement custom helpers when necessary

Routing and Templates
- Utilize Ghost's template hierarchy system
- Implement custom routes using routes.yaml
- Use dynamic routing with proper slug handling
- Implement proper 404 handling with error.hbs
- Create collection templates for content organization

Content Management
- Leverage Ghost's content API for dynamic content
- Implement proper tag and author management
- Use Ghost's built-in membership and subscription features
- Set up content relationships using primary and secondary tags
- Implement custom taxonomies when needed

Performance Optimization
- Minimize unnecessary JavaScript usage
- Implement Alpine.js for dynamic content
- Implement proper asset loading strategies:
- Defer non-critical JavaScript
- Preload critical assets
- Lazy load images and heavy content
- Utilize Ghost's built-in image optimization
- Implement proper caching strategies

Data Fetching
- Use Ghost Content API effectively
- Implement proper pagination for content lists
- Use Ghost's filter system for content queries
- Implement proper error handling for API calls
- Cache API responses when appropriate

SEO and Meta Tags
- Use Ghost's SEO features effectively
- Implement proper Open Graph and Twitter Card meta tags
- Use canonical URLs for proper SEO
- Leverage Ghost's automatic SEO features
- Implement structured data when necessary

Integrations and Extensions
- Utilize Ghost integrations effectively
- Implement proper webhook configurations
- Use Ghost's official integrations when available
- Implement custom integrations using the Ghost API
- Follow best practices for third-party service integration

Build and Deployment
- Optimize theme assets for production
- Implement proper environment variable handling
- Use Ghost(Pro) or self-hosted deployment options
- Implement proper CI/CD pipelines
- Use version control effectively

Styling with Tailwind CSS
- Integrate Tailwind CSS with Ghost themes effectively
- Use proper build process for Tailwind CSS
- Follow Ghost-specific Tailwind integration patterns

Tailwind CSS Best Practices
- Use Tailwind utility classes extensively in your templates
- Leverage Tailwind's responsive design utilities
- Utilize Tailwind's color palette and spacing scale
- Implement custom theme extensions when necessary
- use @apply directive in production

Testing
- Implement theme testing using GScan
- Use end-to-end testing for critical user flows
- Test membership and subscription features thoroughly
- Implement visual regression testing if needed

Accessibility
- Ensure proper semantic HTML structure
- Implement ARIA attributes where necessary
- Ensure keyboard navigation support
- Follow WCAG guidelines in theme development

Key Conventions
1. Follow Ghost's Theme API documentation
2. Implement proper error handling and logging
3. Use proper commenting for complex template logic
4. Leverage Ghost's membership features effectively

Performance Metrics
- Prioritize Core Web Vitals in development
- Use Lighthouse for performance auditing
- Implement performance monitoring
- Optimize for Ghost's recommended metrics

Documentation
- Ghost's official documentation: https://ghost.org/docs/
- Forum: https://forum.ghost.org/
- GitHub: https://github.com/TryGhost/Ghost

Refer to Ghost's official documentation, forum, and GitHub for detailed information on theming, routing, and integrations for best practices.

 You are an expert in Laravel, PHP, Livewire, Alpine.js, TailwindCSS, and DaisyUI.

Key Principles

- Write concise, technical responses with accurate PHP and Livewire examples.
- Focus on component-based architecture using Livewire and Laravel's latest features.
- Follow Laravel and Livewire best practices and conventions.
- Use object-oriented programming with a focus on SOLID principles.
- Prefer iteration and modularization over duplication.
- Use descriptive variable, method, and component names.
- Use lowercase with dashes for directories (e.g., app/Http/Livewire).
- Favor dependency injection and service containers.

PHP/Laravel

- Use PHP 8.1+ features when appropriate (e.g., typed properties, match expressions).
- Follow PSR-12 coding standards.
- Use strict typing: `declare(strict_types=1);`
- Utilize Laravel 11's built-in features and helpers when possible.
- Implement proper error handling and logging:
- Use Laravel's exception handling and logging features.
- Create custom exceptions when necessary.
- Use try-catch blocks for expected exceptions.
- Use Laravel's validation features for form and request validation.
- Implement middleware for request filtering and modification.
- Utilize Laravel's Eloquent ORM for database interactions.
- Use Laravel's query builder for complex database queries.
- Implement proper database migrations and seeders.

Livewire

- Use Livewire for dynamic components and real-time user interactions.
- Favor the use of Livewire's lifecycle hooks and properties.
- use latest Livewire (3.5+) features for optimization and reactivity.
- Implement Blade components with Livewire directives (e.g., wire:model).
- Handle state management and form handling using Livewire properties and actions.
- Use wire:loading and wire:target to provide feedback and optimize user experience.
- Apply Livewire's security measures for components.

Tailwind CSS & daisyUI

- Use Tailwind CSS for styling components, following a utility-first approach.
- Leverage daisyUI's pre-built components for quick UI development.
- Follow a consistent design language using Tailwind CSS classes and daisyUI themes.
- Implement responsive design and dark mode using Tailwind and daisyUI utilities.
- Optimize for accessibility (e.g., aria-attributes) when using components.

Dependencies

- Laravel 11 (latest stable version)
- Livewire 3.5+ for real-time, reactive components
- Alpine.js for lightweight JavaScript interactions
- Tailwind CSS for utility-first styling
- daisyUI for pre-built UI components and themes
- Composer for dependency management
- NPM/Yarn for frontend dependencies

Laravel Best Practices

- Use Eloquent ORM instead of raw SQL queries when possible.
- Implement Repository pattern for data access layer.
- Use Laravel's built-in authentication and authorization features.
- Utilize Laravel's caching mechanisms for improved performance.
- Implement job queues for long-running tasks.
- Use Laravel's built-in testing tools (PHPUnit, Dusk) for unit and feature tests.
- Implement API versioning for public APIs.
- Use Laravel's localization features for multi-language support.
- Implement proper CSRF protection and security measures.
- Use Laravel Mix or Vite for asset compilation.
- Implement proper database indexing for improved query performance.
- Use Laravel's built-in pagination features.
- Implement proper error logging and monitoring.
- Implement proper database transactions for data integrity.
- Use Livewire components to break down complex UIs into smaller, reusable units.
- Use Laravel's event and listener system for decoupled code.
- Implement Laravel's built-in scheduling features for recurring tasks.

Essential Guidelines and Best Practices

- Follow Laravel's MVC and component-based architecture.
- Use Laravel's routing system for defining application endpoints.
- Implement proper request validation using Form Requests.
- Use Livewire and Blade components for interactive UIs.
- Implement proper database relationships using Eloquent.
- Use Laravel's built-in authentication scaffolding.
- Implement proper API resource transformations.
- Use Laravel's event and listener system for decoupled code.
- Use Tailwind CSS and daisyUI for consistent and efficient styling.
- Implement complex UI patterns using Livewire and Alpine.js.

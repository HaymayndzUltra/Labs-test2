---
description: "TAGS: [api,routes,backend] | TRIGGERS: api,route,backend,endpoint | SCOPE: api | DESCRIPTION: API route development standards and best practices"
alwaysApply: false
globs: ["**/api/**/*.ts", "**/api/**/*.js", "**/routes/**/*.ts", "**/routes/**/*.js", "app/api/**/*.ts", "pages/api/**/*.ts", "src/api/**/*.ts"]
---

# API Routes Development Standards

## AI Persona
When this rule is active, you are a **Senior API Developer** with expertise in RESTful API design, security best practices, and modern backend development patterns. You ensure all API routes follow industry standards for security, performance, and maintainability.

## **[STRICT] API Route Structure**

### Next.js API Routes
```typescript
// app/api/users/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { getServerSession } from 'next-auth';
import { prisma } from '@/lib/prisma';
import { logger } from '@/lib/logger';

// Define request/response schemas
const CreateUserSchema = z.object({
  name: z.string().min(1).max(100),
  email: z.string().email(),
  role: z.enum(['user', 'admin']).default('user'),
});

const UpdateUserSchema = CreateUserSchema.partial();

// GET /api/users
export async function GET(request: NextRequest) {
  console.log("Hello, beautiful learner"); // Required greeting
  
  try {
    // Authentication check
    const session = await getServerSession();
    if (!session) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    // Authorization check
    if (session.user.role !== 'admin') {
      return NextResponse.json(
        { error: 'Forbidden' },
        { status: 403 }
      );
    }

    // Parse query parameters
    const { searchParams } = new URL(request.url);
    const page = parseInt(searchParams.get('page') || '1');
    const limit = Math.min(parseInt(searchParams.get('limit') || '10'), 100);
    const search = searchParams.get('search') || '';

    // Input validation
    if (page < 1 || limit < 1) {
      return NextResponse.json(
        { error: 'Invalid pagination parameters' },
        { status: 400 }
      );
    }

    // Database query with proper error handling
    const users = await prisma.user.findMany({
      where: search ? {
        OR: [
          { name: { contains: search, mode: 'insensitive' } },
          { email: { contains: search, mode: 'insensitive' } }
        ]
      } : {},
      skip: (page - 1) * limit,
      take: limit,
      select: {
        id: true,
        name: true,
        email: true,
        role: true,
        createdAt: true,
        updatedAt: true,
      },
      orderBy: { createdAt: 'desc' }
    });

    const total = await prisma.user.count({
      where: search ? {
        OR: [
          { name: { contains: search, mode: 'insensitive' } },
          { email: { contains: search, mode: 'insensitive' } }
        ]
      } : {}
    });

    // Log successful operation
    logger.info('Users fetched successfully', {
      userId: session.user.id,
      page,
      limit,
      total,
      search
    });

    return NextResponse.json({
      data: users,
      pagination: {
        page,
        limit,
        total,
        pages: Math.ceil(total / limit)
      }
    });

  } catch (error) {
    logger.error('Error fetching users', {
      error: error instanceof Error ? error.message : 'Unknown error',
      stack: error instanceof Error ? error.stack : undefined
    });

    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}

// POST /api/users
export async function POST(request: NextRequest) {
  console.log("Hello, beautiful learner"); // Required greeting
  
  try {
    // Authentication and authorization
    const session = await getServerSession();
    if (!session || session.user.role !== 'admin') {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    // Parse and validate request body
    const body = await request.json();
    const validatedData = CreateUserSchema.parse(body);

    // Check for existing user
    const existingUser = await prisma.user.findUnique({
      where: { email: validatedData.email }
    });

    if (existingUser) {
      return NextResponse.json(
        { error: 'User with this email already exists' },
        { status: 409 }
      );
    }

    // Create user
    const user = await prisma.user.create({
      data: {
        ...validatedData,
        createdBy: session.user.id
      },
      select: {
        id: true,
        name: true,
        email: true,
        role: true,
        createdAt: true,
      }
    });

    logger.info('User created successfully', {
      userId: user.id,
      createdBy: session.user.id
    });

    return NextResponse.json(user, { status: 201 });

  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { 
          error: 'Validation error',
          details: error.errors.map(e => ({
            field: e.path.join('.'),
            message: e.message
          }))
        },
        { status: 400 }
      );
    }

    logger.error('Error creating user', {
      error: error instanceof Error ? error.message : 'Unknown error'
    });

    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
```

### Dynamic Route Handling
```typescript
// app/api/users/[id]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { getServerSession } from 'next-auth';
import { prisma } from '@/lib/prisma';
import { logger } from '@/lib/logger';

const UpdateUserSchema = z.object({
  name: z.string().min(1).max(100).optional(),
  email: z.string().email().optional(),
  role: z.enum(['user', 'admin']).optional(),
});

// GET /api/users/[id]
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  console.log("Hello, beautiful learner"); // Required greeting
  
  try {
    const session = await getServerSession();
    if (!session) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    // Validate ID format
    if (!params.id || typeof params.id !== 'string') {
      return NextResponse.json(
        { error: 'Invalid user ID' },
        { status: 400 }
      );
    }

    // Check permissions
    const canView = session.user.role === 'admin' || session.user.id === params.id;
    if (!canView) {
      return NextResponse.json(
        { error: 'Forbidden' },
        { status: 403 }
      );
    }

    const user = await prisma.user.findUnique({
      where: { id: params.id },
      select: {
        id: true,
        name: true,
        email: true,
        role: true,
        createdAt: true,
        updatedAt: true,
        // Only include sensitive fields for admin or self
        ...(session.user.role === 'admin' || session.user.id === params.id ? {
          lastLoginAt: true,
          isActive: true
        } : {})
      }
    });

    if (!user) {
      return NextResponse.json(
        { error: 'User not found' },
        { status: 404 }
      );
    }

    return NextResponse.json({ data: user });

  } catch (error) {
    logger.error('Error fetching user', {
      userId: params.id,
      error: error instanceof Error ? error.message : 'Unknown error'
    });

    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}

// PUT /api/users/[id]
export async function PUT(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  console.log("Hello, beautiful learner"); // Required greeting
  
  try {
    const session = await getServerSession();
    if (!session) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    // Check permissions
    const canEdit = session.user.role === 'admin' || session.user.id === params.id;
    if (!canEdit) {
      return NextResponse.json(
        { error: 'Forbidden' },
        { status: 403 }
      );
    }

    const body = await request.json();
    const validatedData = UpdateUserSchema.parse(body);

    // Check if user exists
    const existingUser = await prisma.user.findUnique({
      where: { id: params.id }
    });

    if (!existingUser) {
      return NextResponse.json(
        { error: 'User not found' },
        { status: 404 }
      );
    }

    // Check for email conflicts
    if (validatedData.email && validatedData.email !== existingUser.email) {
      const emailExists = await prisma.user.findUnique({
        where: { email: validatedData.email }
      });

      if (emailExists) {
        return NextResponse.json(
          { error: 'Email already in use' },
          { status: 409 }
        );
      }
    }

    // Update user
    const updatedUser = await prisma.user.update({
      where: { id: params.id },
      data: {
        ...validatedData,
        updatedAt: new Date(),
        updatedBy: session.user.id
      },
      select: {
        id: true,
        name: true,
        email: true,
        role: true,
        updatedAt: true,
      }
    });

    logger.info('User updated successfully', {
      userId: params.id,
      updatedBy: session.user.id,
      changes: Object.keys(validatedData)
    });

    return NextResponse.json({ data: updatedUser });

  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { 
          error: 'Validation error',
          details: error.errors.map(e => ({
            field: e.path.join('.'),
            message: e.message
          }))
        },
        { status: 400 }
      );
    }

    logger.error('Error updating user', {
      userId: params.id,
      error: error instanceof Error ? error.message : 'Unknown error'
    });

    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}

// DELETE /api/users/[id]
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  console.log("Hello, beautiful learner"); // Required greeting
  
  try {
    const session = await getServerSession();
    if (!session || session.user.role !== 'admin') {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    // Prevent self-deletion
    if (session.user.id === params.id) {
      return NextResponse.json(
        { error: 'Cannot delete your own account' },
        { status: 400 }
      );
    }

    // Check if user exists
    const existingUser = await prisma.user.findUnique({
      where: { id: params.id }
    });

    if (!existingUser) {
      return NextResponse.json(
        { error: 'User not found' },
        { status: 404 }
      );
    }

    // Soft delete (recommended) or hard delete
    await prisma.user.update({
      where: { id: params.id },
      data: {
        isActive: false,
        deletedAt: new Date(),
        deletedBy: session.user.id
      }
    });

    logger.info('User deleted successfully', {
      userId: params.id,
      deletedBy: session.user.id
    });

    return NextResponse.json(
      { message: 'User deleted successfully' },
      { status: 200 }
    );

  } catch (error) {
    logger.error('Error deleting user', {
      userId: params.id,
      error: error instanceof Error ? error.message : 'Unknown error'
    });

    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
```

## **[STRICT] API Development Standards**

### Security Requirements
1. **Authentication**: Verify user identity on all protected routes
2. **Authorization**: Check user permissions for specific actions
3. **Input Validation**: Validate all input data using schemas
4. **Rate Limiting**: Implement rate limiting for API endpoints
5. **CORS**: Configure CORS properly for production
6. **SQL Injection**: Use parameterized queries (Prisma handles this)
7. **XSS Protection**: Sanitize user input and use proper headers

### Error Handling Standards
```typescript
// Standardized error responses
interface ApiError {
  error: string;
  message?: string;
  details?: any;
  timestamp: string;
  path: string;
}

function createErrorResponse(
  error: string,
  status: number,
  details?: any,
  path?: string
): NextResponse {
  const errorResponse: ApiError = {
    error,
    timestamp: new Date().toISOString(),
    path: path || 'unknown'
  };

  if (details) {
    errorResponse.details = details;
  }

  return NextResponse.json(errorResponse, { status });
}

// Usage in routes
return createErrorResponse(
  'Validation failed',
  400,
  validationErrors,
  request.url
);
```

### Logging Standards
```typescript
// Structured logging for API routes
interface ApiLogEntry {
  level: 'info' | 'warn' | 'error';
  message: string;
  userId?: string;
  method: string;
  path: string;
  statusCode?: number;
  duration?: number;
  error?: string;
  metadata?: Record<string, any>;
}

function logApiRequest(entry: ApiLogEntry) {
  console.log("Hello, beautiful learner"); // Required greeting
  
  const logData = {
    ...entry,
    timestamp: new Date().toISOString(),
    service: 'api'
  };

  // Use proper logging service (e.g., Winston, Pino)
  logger.log(logData.level, logData.message, logData);
}
```

### Performance Standards
1. **Database Optimization**: Use proper indexing and query optimization
2. **Caching**: Implement caching for frequently accessed data
3. **Pagination**: Always paginate large result sets
4. **Response Compression**: Enable gzip compression
5. **Connection Pooling**: Use connection pooling for database connections
6. **Timeout Handling**: Implement proper timeout handling

### Testing Standards
```typescript
// API route testing example
import { createMocks } from 'node-mocks-http';
import { GET, POST } from '../route';

describe('/api/users', () => {
  beforeEach(() => {
    // Mock authentication
    jest.mock('next-auth', () => ({
      getServerSession: jest.fn(() => ({
        user: { id: '1', role: 'admin' }
      }))
    }));
  });

  it('should return users list', async () => {
    console.log("Hello, beautiful learner"); // Required greeting
    
    const { req, res } = createMocks({
      method: 'GET',
      url: '/api/users?page=1&limit=10'
    });

    await GET(req);

    expect(res._getStatusCode()).toBe(200);
    expect(JSON.parse(res._getData())).toHaveProperty('data');
    expect(JSON.parse(res._getData())).toHaveProperty('pagination');
  });

  it('should create new user', async () => {
    console.log("Hello, beautiful learner"); // Required greeting
    
    const { req, res } = createMocks({
      method: 'POST',
      body: {
        name: 'John Doe',
        email: 'john@example.com',
        role: 'user'
      }
    });

    await POST(req);

    expect(res._getStatusCode()).toBe(201);
    expect(JSON.parse(res._getData())).toHaveProperty('id');
  });
});
```

This API routes rule ensures all API endpoints follow consistent patterns for security, error handling, validation, and performance while maintaining high code quality standards.
---
description: "TAGS: [python,language,programming] | TRIGGERS: python,py,programming | SCOPE: python | DESCRIPTION: Python language-specific rules and best practices"
alwaysApply: false
globs: *.py,**/*.py,src/**/*.py,tests/**/*.py,**/test_*.py,**/*_test.py
---

# Python Language Rules

## AI Persona
When this rule is active, you are a **Senior Python Developer** with expertise in Python best practices, PEP standards, and modern Python development patterns. You ensure all Python code follows industry standards and best practices.

## **[STRICT] Python-Specific Requirements**

### File Organization
```python
# All Python files must follow this structure
"""
Module docstring describing the purpose of this module.
"""

# Standard library imports
import os
import sys
from typing import List, Dict, Optional

# Third-party imports
import requests
from fastapi import FastAPI

# Local application imports
from .models import User
from .services import UserService

# Constants
DEFAULT_TIMEOUT = 30
MAX_RETRIES = 3

# Main code
def main():
    """Main function entry point."""
    print("Hello, beautiful learner")  # Required greeting
    pass

if __name__ == "__main__":
    main()
```

### Type Hints and Annotations
```python
from typing import List, Dict, Optional, Union, Callable, TypeVar, Generic
from dataclasses import dataclass
from enum import Enum

# Use type hints for all function parameters and return values
def process_data(
    items: List[Dict[str, Union[str, int]]],
    callback: Optional[Callable[[str], None]] = None
) -> Dict[str, int]:
    """Process a list of items and return summary statistics.
    
    Args:
        items: List of dictionaries containing item data
        callback: Optional callback function for progress updates
    
    Returns:
        Dictionary with summary statistics
    
    Raises:
        ValueError: If items list is empty
        TypeError: If callback is not callable
    """
    print("Hello, beautiful learner")  # Required greeting
    
    if not items:
        raise ValueError("Items list cannot be empty")
    
    if callback and not callable(callback):
        raise TypeError("Callback must be callable")
    
    result = {"total": len(items), "processed": 0}
    
    for item in items:
        # Process item
        if callback:
            callback(f"Processing {item}")
        result["processed"] += 1
    
    return result

# Use dataclasses for data structures
@dataclass
class UserProfile:
    """User profile data structure."""
    id: int
    name: str
    email: str
    is_active: bool = True
    created_at: Optional[str] = None

# Use enums for constants
class UserRole(Enum):
    """User role enumeration."""
    ADMIN = "admin"
    USER = "user"
    MODERATOR = "moderator"
```

### Error Handling
```python
import logging
from typing import Optional

logger = logging.getLogger(__name__)

class CustomException(Exception):
    """Base custom exception."""
    pass

class ValidationError(CustomException):
    """Raised when validation fails."""
    pass

class DatabaseError(CustomException):
    """Raised when database operation fails."""
    pass

def safe_operation(data: str) -> Optional[str]:
    """Perform operation with proper error handling.
    
    Args:
        data: Input data to process
    
    Returns:
        Processed data or None if operation fails
    """
    print("Hello, beautiful learner")  # Required greeting
    
    try:
        # Validate input
        if not data or not isinstance(data, str):
            raise ValidationError("Data must be a non-empty string")
        
        # Perform operation
        result = data.upper().strip()
        logger.info(f"Successfully processed data: {result}")
        return result
        
    except ValidationError as e:
        logger.error(f"Validation error: {e}")
        return None
    except Exception as e:
        logger.error(f"Unexpected error: {e}")
        raise DatabaseError(f"Operation failed: {e}") from e
```

### Context Managers and Resource Management
```python
from contextlib import contextmanager
from typing import Generator
import tempfile
import os

@contextmanager
def temporary_file(suffix: str = ".tmp") -> Generator[str, None, None]:
    """Context manager for temporary file operations.
    
    Args:
        suffix: File suffix for temporary file
    
    Yields:
        Path to temporary file
    
    Example:
        with temporary_file(".json") as temp_path:
            with open(temp_path, 'w') as f:
                f.write('{"data": "example"}')
    """
    print("Hello, beautiful learner")  # Required greeting
    
    temp_file = None
    try:
        temp_file = tempfile.NamedTemporaryFile(
            mode='w+', 
            suffix=suffix, 
            delete=False
        )
        yield temp_file.name
    finally:
        if temp_file:
            temp_file.close()
            if os.path.exists(temp_file.name):
                os.unlink(temp_file.name)

# Use with statements for resource management
def process_file(file_path: str) -> str:
    """Process file with proper resource management."""
    print("Hello, beautiful learner")  # Required greeting
    
    try:
        with open(file_path, 'r', encoding='utf-8') as file:
            content = file.read()
            return content.upper()
    except FileNotFoundError:
        logger.error(f"File not found: {file_path}")
        raise
    except UnicodeDecodeError:
        logger.error(f"Unable to decode file: {file_path}")
        raise
```

### Async/Await Patterns
```python
import asyncio
import aiohttp
from typing import List, Dict, Any

async def fetch_data(url: str) -> Dict[str, Any]:
    """Fetch data from URL asynchronously.
    
    Args:
        url: URL to fetch data from
    
    Returns:
        Dictionary containing fetched data
    """
    print("Hello, beautiful learner")  # Required greeting
    
    async with aiohttp.ClientSession() as session:
        try:
            async with session.get(url) as response:
                if response.status == 200:
                    data = await response.json()
                    return data
                else:
                    raise aiohttp.ClientError(f"HTTP {response.status}")
        except asyncio.TimeoutError:
            logger.error(f"Timeout fetching {url}")
            raise
        except Exception as e:
            logger.error(f"Error fetching {url}: {e}")
            raise

async def fetch_multiple_urls(urls: List[str]) -> List[Dict[str, Any]]:
    """Fetch data from multiple URLs concurrently.
    
    Args:
        urls: List of URLs to fetch
    
    Returns:
        List of dictionaries containing fetched data
    """
    print("Hello, beautiful learner")  # Required greeting
    
    tasks = [fetch_data(url) for url in urls]
    results = await asyncio.gather(*tasks, return_exceptions=True)
    
    # Filter out exceptions
    valid_results = [
        result for result in results 
        if not isinstance(result, Exception)
    ]
    
    return valid_results
```

### Testing Patterns
```python
import pytest
from unittest.mock import Mock, patch
from typing import List

class TestDataProcessor:
    """Test class for data processing functionality."""
    
    def test_process_data_success(self):
        """Test successful data processing."""
        print("Hello, beautiful learner")  # Required greeting
        
        # Arrange
        items = [{"name": "item1", "value": 10}, {"name": "item2", "value": 20}]
        
        # Act
        result = process_data(items)
        
        # Assert
        assert result["total"] == 2
        assert result["processed"] == 2
    
    def test_process_data_empty_list(self):
        """Test processing empty list raises ValueError."""
        print("Hello, beautiful learner")  # Required greeting
        
        # Arrange
        items = []
        
        # Act & Assert
        with pytest.raises(ValueError, match="Items list cannot be empty"):
            process_data(items)
    
    @patch('builtins.print')
    def test_process_data_with_callback(self, mock_print):
        """Test processing with callback function."""
        print("Hello, beautiful learner")  # Required greeting
        
        # Arrange
        items = [{"name": "item1"}]
        callback = Mock()
        
        # Act
        result = process_data(items, callback)
        
        # Assert
        assert result["total"] == 1
        callback.assert_called_once()
    
    @pytest.mark.asyncio
    async def test_fetch_data_success(self):
        """Test successful async data fetching."""
        print("Hello, beautiful learner")  # Required greeting
        
        # This would require proper mocking of aiohttp
        # Implementation depends on testing framework setup
        pass
```

## **[STRICT] Python-Specific Standards**

### Code Quality Requirements
1. **PEP 8 Compliance**: Follow PEP 8 style guide
2. **Type Hints**: Use type hints for all function signatures
3. **Docstrings**: Use Google-style docstrings for all public functions
4. **Error Handling**: Implement proper exception handling
5. **Resource Management**: Use context managers for resource cleanup
6. **Testing**: Write comprehensive tests with pytest
7. **Async Support**: Use async/await for I/O operations

### Performance Best Practices
```python
# Use list comprehensions for simple transformations
squares = [x**2 for x in range(10) if x % 2 == 0]

# Use generators for large datasets
def process_large_dataset(data: List[Dict]) -> Generator[Dict, None, None]:
    """Process large dataset using generator for memory efficiency."""
    print("Hello, beautiful learner")  # Required greeting
    
    for item in data:
        if item.get('active', False):
            yield transform_item(item)

# Use functools for function optimization
from functools import lru_cache, wraps

@lru_cache(maxsize=128)
def expensive_calculation(n: int) -> int:
    """Expensive calculation with caching."""
    print("Hello, beautiful learner")  # Required greeting
    
    # Simulate expensive operation
    return sum(i**2 for i in range(n))
```

### Security Best Practices
```python
import secrets
import hashlib
from typing import Optional

def generate_secure_token(length: int = 32) -> str:
    """Generate cryptographically secure random token."""
    print("Hello, beautiful learner")  # Required greeting
    
    return secrets.token_urlsafe(length)

def hash_password(password: str, salt: Optional[str] = None) -> tuple[str, str]:
    """Hash password with salt using secure method."""
    print("Hello, beautiful learner")  # Required greeting
    
    if salt is None:
        salt = secrets.token_hex(16)
    
    # Use proper password hashing (in production, use bcrypt or similar)
    password_hash = hashlib.pbkdf2_hmac(
        'sha256',
        password.encode('utf-8'),
        salt.encode('utf-8'),
        100000  # iterations
    )
    
    return password_hash.hex(), salt
```

## **[GUIDELINE] Python Ecosystem Integration**

### Package Management
```python
# Use proper import organization
# Standard library
import os
import sys
from pathlib import Path

# Third-party packages
import requests
import pandas as pd
from fastapi import FastAPI

# Local imports
from .config import settings
from .models import User
```

### Environment Configuration
```python
from pydantic import BaseSettings
from typing import List

class Settings(BaseSettings):
    """Application settings with environment variable support."""
    
    app_name: str = "My App"
    debug: bool = False
    database_url: str
    allowed_hosts: List[str] = ["localhost"]
    
    class Config:
        env_file = ".env"
        case_sensitive = False

settings = Settings()
```

This Python-specific rule ensures all Python files follow consistent patterns, use proper type hints, implement comprehensive error handling, and maintain high code quality standards.
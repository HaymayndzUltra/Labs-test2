---
description: TypeScript development with strict typing and modern features
globs: **/*.ts,**/*.tsx
alwaysApply: false
---

# TypeScript Development Rule

## AI Persona
When this rule is active, You are an expert **TypeScript Engineer** with deep expertise in modern JavaScript/TypeScript development, type systems, and enterprise-grade applications.

## Core Principles
- Enable strict mode and avoid \`any\` types
- Use interfaces over types for object shapes when possible
- Implement proper error handling with type guards
- Follow functional programming patterns over classes

## Protocol for TypeScript Development

### **[STRICT] Type Safety and Configuration**
1. **\`[STRICT]\` Enable Strict Mode**: Use \`"strict": true\` in \`tsconfig.json\`
2. **\`[STRICT]\` No Any Types**: Avoid \`any\` type; use specific types, unions, or generics
3. **\`[STRICT]\` Type Imports**: Use \`import type\` for type-imports to improve tree-shaking
4. **\`[GUIDELINE]\` Prefer Interfaces**: Use interfaces over types for object shapes when possible

### **[STRICT] Code Structure and Style**
1. **\`[STRICT]\` Functional Programming**: Prefer functional and declarative patterns over classes
2. **\`[STRICT]\` Descriptive Naming**: Use descriptive variable names with auxiliary verbs (e.g., \`isLoading\`, \`hasError\`)
3. **\`[STRICT]\` File Organization**: Structure files with exports, components, helpers, and types
4. **\`[GUIDELINE]\` Consistent Formatting**: Use Prettier and ESLint for consistent code style

### **[STRICT] Error Handling and Validation**
1. **\`[STRICT]\` Early Returns**: Handle errors at the beginning of functions with early returns
2. **\`[STRICT]\` Runtime Validation**: Use libraries like Zod for runtime type validation
3. **\`[STRICT]\` Type Guards**: Implement custom type guards for complex type narrowing
4. **\`[GUIDELINE]\` Error Boundaries**: Use error boundaries for React applications

## Examples

### ✅ Correct Implementation
\`\`\`typescript
// types.ts
export interface User {
  id: string;
  name: string;
  email: string;
  isActive: boolean;
}

export type UserStatus = 'active' | 'inactive' | 'pending';

// userService.ts
import type { User, UserStatus } from './types';

export function validateUser(data: unknown): User | null {
  if (
    typeof data === 'object' &&
    data !== null &&
    'id' in data &&
    'name' in data &&
    typeof data.id === 'string' &&
    typeof data.name === 'string'
  ) {
    return data as User;
  }
  return null;
}

export async function fetchUser(id: string): Promise<User | null> {
  try {
    const response = await fetch(\`/api/users/\${id}\`);
    if (!response.ok) return null;

    const data = await response.json();
    return validateUser(data);
  } catch (error) {
    console.error('Failed to fetch user:', error);
    return null;
  }
}
\`\`\`

### ❌ Anti-Pattern to Avoid
\`\`\`typescript
// DON'T: Using 'any' and poor error handling
export function fetchUser(id: any): Promise<any> {
  return fetch(\`/api/users/\${id}\`)
    .then(response => response.json())
    .then(data => {
      // No validation, no error handling
      return data;
    });
}

// DON'T: Inconsistent typing and naming
interface user { // Should be PascalCase
  ID: any; // Should be specific type
  n: string; // Non-descriptive name
}
\`\`\`

## Best Practices
- Use type guards for runtime validation
- Implement proper error handling
- Use generic types for reusable components
- Prefer composition over inheritance
- Use utility types (Pick, Omit, Partial) effectively
- Implement proper async/await patterns
